File: ./Assignment2/interrupts.cpp
File: ./Assignment2/inputs/program2.txt
File: ./Assignment2/inputs/program1.txt
File: ./Assignment2/inputs/outputs/execution.txt
File: ./Assignment2/inputs/outputs/system_status.txt
File: ./Assignment2/inputs/vector_table.txt
File: ./Assignment2/inputs/external_files.txt
File: ./Assignment2/inputs/trace.txt
File: ./Assignment2/tests/1/program2.txt
File: ./Assignment2/tests/1/program1.txt
File: ./Assignment2/tests/1/outputs/execution.txt
File: ./Assignment2/tests/1/outputs/system_status.txt
File: ./Assignment2/tests/1/vector_table.txt
File: ./Assignment2/tests/1/external_files.txt
File: ./Assignment2/tests/1/trace.txt
File: ./Assignment2/tests/2/program2.txt
File: ./Assignment2/tests/2/program1.txt
File: ./Assignment2/tests/2/outputs/execution.txt
File: ./Assignment2/tests/2/outputs/system_status.txt
File: ./Assignment2/tests/2/vector_table.txt
File: ./Assignment2/tests/2/external_files.txt
File: ./Assignment2/tests/2/trace.txt
File: ./Assignment2/tests/5/program5.txt
File: ./Assignment2/tests/5/program2.txt
File: ./Assignment2/tests/5/program1.txt
File: ./Assignment2/tests/5/outputs/execution.txt
File: ./Assignment2/tests/5/outputs/system_status.txt
File: ./Assignment2/tests/5/program3.txt
File: ./Assignment2/tests/5/program4.txt
File: ./Assignment2/tests/5/vector_table.txt
File: ./Assignment2/tests/5/external_files.txt
File: ./Assignment2/tests/5/trace.txt
File: ./Assignment2/tests/ex2/program2.txt
File: ./Assignment2/tests/ex2/program1.txt
File: ./Assignment2/tests/ex2/outputs/execution.txt
File: ./Assignment2/tests/ex2/outputs/system_status.txt
File: ./Assignment2/tests/ex2/vector_table.txt
File: ./Assignment2/tests/ex2/external_files.txt
File: ./Assignment2/tests/ex2/trace.txt
File: ./Assignment2/tests/4/program2.txt
File: ./Assignment2/tests/4/program1.txt
File: ./Assignment2/tests/4/outputs/execution.txt
File: ./Assignment2/tests/4/outputs/system_status.txt
File: ./Assignment2/tests/4/program3.txt
File: ./Assignment2/tests/4/program4.txt
File: ./Assignment2/tests/4/vector_table.txt
File: ./Assignment2/tests/4/external_files.txt
File: ./Assignment2/tests/4/trace.txt
File: ./Assignment2/tests/ex1/program1.txt
File: ./Assignment2/tests/ex1/outputs/execution.txt
File: ./Assignment2/tests/ex1/outputs/system_status.txt
File: ./Assignment2/tests/ex1/vector_table.txt
File: ./Assignment2/tests/ex1/external_files.txt
File: ./Assignment2/tests/ex1/trace.txt
File: ./Assignment2/tests/3/program2.txt
File: ./Assignment2/tests/3/program1.txt
File: ./Assignment2/tests/3/outputs/execution.txt
File: ./Assignment2/tests/3/outputs/system_status.txt
File: ./Assignment2/tests/3/program3.txt
File: ./Assignment2/tests/3/vector_table.txt
File: ./Assignment2/tests/3/external_files.txt
File: ./Assignment2/tests/3/trace.txt
File: ./Assignment2/output/run.sh
File: ./Assignment3/interrupts.cpp
File: ./Assignment3/inputs/program2.txt
File: ./Assignment3/inputs/program1.txt
File: ./Assignment3/inputs/outputs/execution.txt
File: ./Assignment3/inputs/outputs/system_status.txt
File: ./Assignment3/inputs/vector_table.txt
File: ./Assignment3/inputs/external_files.txt
File: ./Assignment3/inputs/trace.txt
File: ./Assignment3/output/run.sh
File: ./concat.txt
File: ./Assignment1/Part2/simulations/example/execution2.txt
File: ./Assignment1/Part2/simulations/example/execution.txt
File: ./Assignment1/Part2/simulations/example/vector_table.txt
File: ./Assignment1/Part2/simulations/example/execution3.txt
File: ./Assignment1/Part2/simulations/example/trace.txt
File: ./Assignment1/Part2/simulations/cpu_speed/trace_full_speed.txt
File: ./Assignment1/Part2/simulations/cpu_speed/trace_quarter_speed.txt
File: ./Assignment1/Part2/simulations/cpu_speed/vector_table.txt
File: ./Assignment1/Part2/simulations/cpu_speed/run.sh
File: ./Assignment1/Part2/simulations/cpu_speed/trace_half_speed.txt
File: ./Assignment1/Part2/simulations/cpu_speed/output/execution_full.txt
File: ./Assignment1/Part2/simulations/cpu_speed/output/execution_half.txt
File: ./Assignment1/Part2/simulations/cpu_speed/output/execution_quarter.txt
File: ./Assignment1/Part2/simulations/context_switch/vector_table.txt
File: ./Assignment1/Part2/simulations/context_switch/run.sh
File: ./Assignment1/Part2/simulations/context_switch/trace.txt
File: ./Assignment1/Part2/simulations/context_switch/output/execution_10_20.txt
File: ./Assignment1/Part2/simulations/context_switch/output/execution_3_5.txt
File: ./Assignment1/Part2/simulations/context_switch/output/execution_5_10.txt
File: ./Assignment1/Part2/simulations/context_switch/output/execution_1_3.txt
File: ./Assignment1/Part2/simulations/isr/trace_3.txt
File: ./Assignment1/Part2/simulations/isr/vector_table.txt
File: ./Assignment1/Part2/simulations/isr/run.sh
File: ./Assignment1/Part2/simulations/isr/trace_1.txt
File: ./Assignment1/Part2/simulations/isr/trace_4.txt
File: ./Assignment1/Part2/simulations/isr/output/execution_5.txt
File: ./Assignment1/Part2/simulations/isr/output/execution_4.txt
File: ./Assignment1/Part2/simulations/isr/output/execution_2.txt
File: ./Assignment1/Part2/simulations/isr/output/execution_3.txt
File: ./Assignment1/Part2/simulations/isr/output/execution_1.txt
File: ./Assignment1/Part2/simulations/isr/trace_5.txt
File: ./Assignment1/Part2/simulations/isr/trace_2.txt
File: ./Assignment1/Part2/vector_table.txt
File: ./Assignment1/Part2/interrupts.cpp
File: ./Assignment1/Part2/contributions.txt
File: ./Assignment1/run.sh
#include "interrupts.hpp"

// Define memory partitions
std::vector<MemoryPartition> memory_partitions = {
    {1, 40, "free"}, {2, 25, "free"}, {3, 15, "free"},
    {4, 10, "free"}, {5, 8, "free"}, {6, 2, "occupied"}
};
std::vector<PCB> pcb_table;
std::vector<ExternalFile> external_files;
std::map<int, std::string> vector_table;

unsigned int current_pid = 0;
int current_time = 0;

std::string execution_log;

// Helper function to split a string by a delimiter
std::vector<std::string> split_delim(const std::string& s, const std::string& delimiter) {
    std::vector<std::string> tokens;
    size_t last = 0;
    size_t next = 0;
    while ((next = s.find(delimiter, last)) != std::string::npos) {
        tokens.push_back(s.substr(last, next - last));
        last = next + 1;
    }
    tokens.push_back(s.substr(last));
    return tokens;
}

// Load external files from a given file path
void load_external_files(const std::string& file_path) {
    std::ifstream file(file_path);
    std::string line;
        if (!file.is_open()) {
        throw std::runtime_error("Failed to open file: " + file_path);
    }
    while (std::getline(file, line)) {
        auto parts = split_delim(line, ",");
        if (parts.size() == 2) {
            external_files.push_back({parts[0], static_cast<unsigned int>(std::stoi(parts[1]))});
        }
    }
}

// Load vector table from a given file path
void load_vector_table(const std::string& file_path) {
    std::ifstream file(file_path);
    std::string line;
    int vector_num = 0;
    while (std::getline(file, line)) {
        vector_table[vector_num] = line;
        vector_num++;
    }
}

// Initialize the Process Control Block (PCB)
void init_pcb() {
    pcb_table.push_back({current_pid, "init", 6, 1, 0, "Ready"});
}

// Log a step in the execution process
void log_step(const std::string& step, int duration) {
    execution_log += std::to_string(current_time) + ", " + std::to_string(duration) + ", " + step + "\n";
    current_time += duration;
}

// Simulate a system call
void simulate_syscall(int vector_num) {
    log_step("switch to kernel mode", 1);
    log_step("context saved", 3);
    std::stringstream ss;
    ss << "find vector " << vector_num << " in memory position 0x" 
       << std::setfill('0') << std::setw(4) << std::hex << (ADDR_BASE + (vector_num * VECTOR_SIZE));
    log_step(ss.str(), 1);
    log_step("load address " + vector_table[vector_num] + " into the PC", 1);
}

// Save the current system status to a file
void save_system_status(const std::string& output_file_path) {
    std::ofstream output_file(output_file_path, std::ios::app);
    output_file << "\nSave Time: " << current_time << " ms\n";
    output_file << "+--------------------------------------------+\n";
    output_file << "| PID |Program Name |Partition Number | size |\n";
    output_file << "+--------------------------------------------+\n";
    for (const auto& pcb : pcb_table) {
        output_file << "| " << std::setw(3) << pcb.pid << " | " 
                    << std::setw(11) << std::left << pcb.name << " | " 
                    << std::setw(16) << std::left << pcb.partition << " | " 
                    << std::setw(4) << std::left << pcb.size << " |\n";
    }
    output_file << "+--------------------------------------------+\n";
}

// Simulate the fork system call
void simulate_fork(const std::string& output_directory) {
    simulate_syscall(2);
    log_step("FORK: copy parent PCB to child PCB", 8);
    
    PCB parent = pcb_table.back();
    PCB child = parent;
    child.pid = ++current_pid;
    child.state = "Ready";
    pcb_table.push_back(child);

    log_step("scheduler called", 2);
    log_step("IRET", 1);
    
    save_system_status(output_directory + "/system_status.txt");
}

// Simulate the exec system call
void simulate_exec(const std::string& program_name, const std::string& output_directory) {
    simulate_syscall(3);
    
    auto it = std::find_if(external_files.begin(), external_files.end(),
                           [&](const ExternalFile& ef) { return ef.name == program_name; });

    unsigned int program_size = it->size;
    log_step("EXEC: load " + program_name + " of size " + std::to_string(program_size) + "Mb", 30);

    // Find a suitable memory partition
    auto partition_it = std::min_element(memory_partitions.begin(), memory_partitions.end(),
                                         [&](const MemoryPartition& a, const MemoryPartition& b) {
                                             return (a.status == "free" && a.size >= program_size && a.size < b.size) ||
                                                    (b.status != "free" || b.size < program_size);
                                         });

    log_step("found partition " + std::to_string(partition_it->number) + " with " + std::to_string(partition_it->size) + "Mb of space", 10);
    log_step("partition " + std::to_string(partition_it->number) + " marked as occupied", 6);

    partition_it->status = "occupied";
    
    PCB& current_pcb = pcb_table.back();
    current_pcb.name = program_name;
    current_pcb.partition = partition_it->number;
    current_pcb.size = program_size;

    log_step("updating PCB with new information", 2);
    log_step("scheduler called", 2);
    log_step("IRET", 1);
    
    save_system_status(output_directory + "/system_status.txt");
}

// Simulate CPU execution
void simulate_cpu(int duration) {
    log_step("CPU", duration);
}

// Simulate a general system call
void simulate_syscall(int syscall_num, int duration) {
    simulate_syscall(syscall_num);
    log_step("SYSCALL: run the ISR", duration / 3);
    log_step("transfer data", (duration * 2) / 3);
    log_step("check for errors", 13);
    log_step("IRET", 1);
}

// Execute a program
void execute_program(const std::string& program_name, const std::string& output_directory, const std::string& input_directory) {
    std::string program_file = input_directory + "/" + program_name + ".txt";
    std::ifstream program(program_file);

    std::string line;
    while (std::getline(program, line)) {
        auto parts = split_delim(line, ",");
        if (parts.empty()) continue;

        if (parts[0] == "FORK") {
            simulate_fork(output_directory);
        } else if (parts[0].substr(0, 4) == "EXEC") {
            auto exec_parts = split_delim(parts[0], " ");
            if (exec_parts.size() >= 2) {
                simulate_exec(exec_parts[1], output_directory);
                execute_program(exec_parts[1], output_directory, input_directory);
            }
        } else if (parts[0] == "CPU") {
            if (parts.size() >= 2) {
                simulate_cpu(std::stoi(parts[1]));
            }
        } else if (parts[0].substr(0, 7) == "SYSCALL") {
            auto syscall_parts = split_delim(parts[0], " ");
            if (syscall_parts.size() >= 2 && parts.size() >= 2) {
                simulate_syscall(std::stoi(syscall_parts[1]), std::stoi(parts[1]));
            }
        }
    }
}

// Process the trace file
void process_trace(const std::string& trace_file_path, const std::string& output_directory,  const std::string& input_directory) {
    std::ifstream trace_file(trace_file_path);
    std::string line;
    while (std::getline(trace_file, line)) {
        auto parts = split_delim(line, ",");
        if (parts.empty()) continue;
        
        if (parts[0] == "FORK") {
            simulate_fork(output_directory);
        } else if (parts[0].substr(0, 4) == "EXEC") {
            auto exec_parts = split_delim(parts[0], " ");
            if (exec_parts.size() >= 2) {
                simulate_exec(exec_parts[1], output_directory);
                execute_program(exec_parts[1], output_directory, input_directory);
            }
        } else if (parts[0] == "CPU") {
            if (parts.size() >= 2) {
                simulate_cpu(std::stoi(parts[1]));
            }
        } else if (parts[0].substr(0, 7) == "SYSCALL") {
            auto syscall_parts = split_delim(parts[0], " ");
            if (syscall_parts.size() >= 2 && parts.size() >= 2) {
                simulate_syscall(std::stoi(syscall_parts[1]), std::stoi(parts[1]));
            }
        }
    }
}

int main(int argc, char** argv) {
    if (argc != 2) {
        std::cerr << "Usage: " << argv[0] << " <PATH TO INPUT DIRECTORY>" << std::endl;
        return 1;
    }

    std::string input_directory(argv[1]);
    std::string output_directory = input_directory + "/outputs";
    mkdir(output_directory.c_str(), 0777);

    // Delete existing output files if they exist
    std::string system_status_file = output_directory + "/system_status.txt";
    std::string execution_file = output_directory + "/execution.txt";
    std::remove(system_status_file.c_str());
    std::remove(execution_file.c_str());

    // Load necessary data
    load_external_files(input_directory + "/external_files.txt");
    load_vector_table(input_directory + "/vector_table.txt");
    init_pcb();

    // Save initial system status
    save_system_status(system_status_file);

    // Process the trace file
    process_trace(input_directory + "/trace.txt", output_directory, input_directory);

    // Write execution log to file
    std::ofstream execution_output(execution_file);
    if (execution_output.is_open()) {
        execution_output << execution_log;
        execution_output.close();
    } else {
        std::cerr << "Error opening file for writing: " << execution_file << std::endl;
    }

    std::cout << "Output generated in " << output_directory << std::endl;
    return 0;
}SYSCALL 4, 125CPU, 1000, 1, switch to kernel mode
1, 7, context saved
8, 1, find vector 2 in memory position 0x0008
9, 1, load address 0X0695 into the PC
10, 4, FORK: copy parent PCB to child PCB
14, 9, scheduler called
23, 1, IRET
24, 1, switch to kernel mode
25, 7, context saved
32, 1, find vector 3 in memory position 0x000c
33, 1, load address 0X042B into the PC
34, 8, EXEC: load program1 of size 10Mb
42, 4, found partition 1 with 40Mb of space
46, 4, partition 1 marked as occupied
50, 1, updating PCB with new information
51, 5, scheduler called
56, 1, IRET
57, 1, switch to kernel mode
58, 3, context saved
61, 1, find vector 2 in memory position 0x0008
62, 1, load address 0X0695 into the PC
63, 5, FORK: copy parent PCB to child PCB
68, 4, scheduler called
72, 1, IRET
73, 1, switch to kernel mode
74, 7, context saved
81, 1, find vector 3 in memory position 0x000c
82, 1, load address 0X042B into the PC
83, 4, EXEC: load program2 of size 15Mb
87, 10, found partition 2 with 25Mb of space
97, 4, partition 2 marked as occupied
101, 6, updating PCB with new information
107, 6, scheduler called
113, 1, IRET
!-----------------------------------------------------------!
Save Time: 0 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
+--------------------------------------------+
!-----------------------------------------------------------!

!-----------------------------------------------------------!
Save Time: 114 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
| 1   | program1    | 1                | 10   |
| 2   | program2    | 2                | 15   |
+--------------------------------------------+
!-----------------------------------------------------------!

0X01E3
0X029C
0X0695
0X042B
0X0292
0X048B
0X0639
0X00BD
0X06EF
0X036C
0X07B0
0X01F8
0X03B9
0X06C7
0X0165
0X0584
0X02DF
0X05B3
0X060A
0X0765
0X07B7
0X0523
0X03B7
0X028C
0X05E8
0X05D3
program1, 10
program2, 15FORK, 10
EXEC program1, 50
FORK, 15
EXEC program2, 25SYSCALL 4, 125CPU, 1000, 1, switch to kernel mode
1, 3, context saved
4, 1, find vector 2 in memory position 0x0004
5, 1, load address 0X0695 into the PC
6, 8, FORK: copy parent PCB to child PCB
14, 2, scheduler called
16, 1, IRET
17, 1, switch to kernel mode
18, 3, context saved
21, 1, find vector 3 in memory position 0x0006
22, 1, load address 0X042B into the PC
23, 30, EXEC: load program1 of size 10Mb
53, 10, found partition 4 with 10Mb of space
63, 6, partition 4 marked as occupied
69, 2, updating PCB with new information
71, 2, scheduler called
73, 1, IRET
74, 100, CPU
174, 1, switch to kernel mode
175, 3, context saved
178, 1, find vector 2 in memory position 0x0004
179, 1, load address 0X0695 into the PC
180, 8, FORK: copy parent PCB to child PCB
188, 2, scheduler called
190, 1, IRET
191, 1, switch to kernel mode
192, 3, context saved
195, 1, find vector 3 in memory position 0x0006
196, 1, load address 0X042B into the PC
197, 30, EXEC: load program2 of size 15Mb
227, 10, found partition 3 with 15Mb of space
237, 6, partition 3 marked as occupied
243, 2, updating PCB with new information
245, 2, scheduler called
247, 1, IRET
248, 1, switch to kernel mode
249, 3, context saved
252, 1, find vector 4 in memory position 0x0008
253, 1, load address 0X0292 into the PC
254, 41, SYSCALL: run the ISR
295, 83, transfer data
378, 13, check for errors
391, 1, IRET

Save Time: 0 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
+--------------------------------------------+

Save Time: 17 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
| 1   | init        | 6                | 1    |
+--------------------------------------------+

Save Time: 74 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
| 1   | program1    | 4                | 10   |
+--------------------------------------------+

Save Time: 191 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
| 1   | program1    | 4                | 10   |
| 2   | program1    | 4                | 10   |
+--------------------------------------------+

Save Time: 248 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
| 1   | program1    | 4                | 10   |
| 2   | program2    | 3                | 15   |
+--------------------------------------------+
0X01E3
0X029C
0X0695
0X042B
0X0292
0X048B
0X0639
0X00BD
0X06EF
0X036C
0X07B0
0X01F8
0X03B9
0X06C7
0X0165
0X0584
0X02DF
0X05B3
0X060A
0X0765
0X07B7
0X0523
0X03B7
0X028C
0X05E8
0X05D3
program1, 10
program2, 15FORK, 10
EXEC program1, 50
FORK, 15
EXEC program2, 25CPU, 53
SYSCALL 5, 128
END_IO 11, 115FORK, 15
EXEC program2, 330, 1, switch to kernel mode
1, 3, context saved
4, 1, find vector 2 in memory position 0x0004
5, 1, load address 0X0695 into the PC
6, 8, FORK: copy parent PCB to child PCB
14, 2, scheduler called
16, 1, IRET
17, 1, switch to kernel mode
18, 3, context saved
21, 1, find vector 3 in memory position 0x0006
22, 1, load address 0X042B into the PC
23, 30, EXEC: load program1 of size 20Mb
53, 10, found partition 2 with 25Mb of space
63, 6, partition 2 marked as occupied
69, 2, updating PCB with new information
71, 2, scheduler called
73, 1, IRET
74, 1, switch to kernel mode
75, 3, context saved
78, 1, find vector 2 in memory position 0x0004
79, 1, load address 0X0695 into the PC
80, 8, FORK: copy parent PCB to child PCB
88, 2, scheduler called
90, 1, IRET
91, 1, switch to kernel mode
92, 3, context saved
95, 1, find vector 3 in memory position 0x0006
96, 1, load address 0X042B into the PC
97, 30, EXEC: load program2 of size 15Mb
127, 10, found partition 3 with 15Mb of space
137, 6, partition 3 marked as occupied
143, 2, updating PCB with new information
145, 2, scheduler called
147, 1, IRET
148, 53, CPU
201, 1, switch to kernel mode
202, 3, context saved
205, 1, find vector 5 in memory position 0x000a
206, 1, load address 0X048B into the PC
207, 42, SYSCALL: run the ISR
249, 85, transfer data
334, 13, check for errors
347, 1, IRET

Save Time: 0 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
+--------------------------------------------+

Save Time: 17 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
| 1   | init        | 6                | 1    |
+--------------------------------------------+

Save Time: 74 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
| 1   | program1    | 2                | 20   |
+--------------------------------------------+

Save Time: 91 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
| 1   | program1    | 2                | 20   |
| 2   | program1    | 2                | 20   |
+--------------------------------------------+

Save Time: 148 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
| 1   | program1    | 2                | 20   |
| 2   | program2    | 3                | 15   |
+--------------------------------------------+
0X01E3
0X029C
0X0695
0X042B
0X0292
0X048B
0X0639
0X00BD
0X06EF
0X036C
0X07B0
0X01F8
0X03B9
0X06C7
0X0165
0X0584
0X02DF
0X05B3
0X060A
0X0765
0X07B7
0X0523
0X03B7
0X028C
0X05E8
0X05D3
program1, 20
program2, 15FORK, 17
EXEC program1, 16SYSCALL 7, 130
CPU, 45
END_IO 10, 190FORK, 12
EXEC program3, 36
CPU, 70FORK, 13
EXEC program2, 28
SYSCALL 5, 1000, 1, switch to kernel mode
1, 3, context saved
4, 1, find vector 2 in memory position 0x0004
5, 1, load address 0X0695 into the PC
6, 8, FORK: copy parent PCB to child PCB
14, 2, scheduler called
16, 1, IRET
17, 1, switch to kernel mode
18, 3, context saved
21, 1, find vector 3 in memory position 0x0006
22, 1, load address 0X042B into the PC
23, 30, EXEC: load program1 of size 5Mb
53, 10, found partition 5 with 8Mb of space
63, 6, partition 5 marked as occupied
69, 2, updating PCB with new information
71, 2, scheduler called
73, 1, IRET
74, 1, switch to kernel mode
75, 3, context saved
78, 1, find vector 2 in memory position 0x0004
79, 1, load address 0X0695 into the PC
80, 8, FORK: copy parent PCB to child PCB
88, 2, scheduler called
90, 1, IRET
91, 1, switch to kernel mode
92, 3, context saved
95, 1, find vector 3 in memory position 0x0006
96, 1, load address 0X042B into the PC
97, 30, EXEC: load program2 of size 9Mb
127, 10, found partition 4 with 10Mb of space
137, 6, partition 4 marked as occupied
143, 2, updating PCB with new information
145, 2, scheduler called
147, 1, IRET
148, 1, switch to kernel mode
149, 3, context saved
152, 1, find vector 2 in memory position 0x0004
153, 1, load address 0X0695 into the PC
154, 8, FORK: copy parent PCB to child PCB
162, 2, scheduler called
164, 1, IRET
165, 1, switch to kernel mode
166, 3, context saved
169, 1, find vector 3 in memory position 0x0006
170, 1, load address 0X042B into the PC
171, 30, EXEC: load program3 of size 14Mb
201, 10, found partition 3 with 15Mb of space
211, 6, partition 3 marked as occupied
217, 2, updating PCB with new information
219, 2, scheduler called
221, 1, IRET
222, 1, switch to kernel mode
223, 3, context saved
226, 1, find vector 2 in memory position 0x0004
227, 1, load address 0X0695 into the PC
228, 8, FORK: copy parent PCB to child PCB
236, 2, scheduler called
238, 1, IRET
239, 1, switch to kernel mode
240, 3, context saved
243, 1, find vector 3 in memory position 0x0006
244, 1, load address 0X042B into the PC
245, 30, EXEC: load program4 of size 19Mb
275, 10, found partition 2 with 25Mb of space
285, 6, partition 2 marked as occupied
291, 2, updating PCB with new information
293, 2, scheduler called
295, 1, IRET
296, 1, switch to kernel mode
297, 3, context saved
300, 1, find vector 2 in memory position 0x0004
301, 1, load address 0X0695 into the PC
302, 8, FORK: copy parent PCB to child PCB
310, 2, scheduler called
312, 1, IRET
313, 1, switch to kernel mode
314, 3, context saved
317, 1, find vector 3 in memory position 0x0006
318, 1, load address 0X042B into the PC
319, 30, EXEC: load program5 of size 24Mb
349, 10, found partition 1 with 40Mb of space
359, 6, partition 1 marked as occupied
365, 2, updating PCB with new information
367, 2, scheduler called
369, 1, IRET
370, 1, switch to kernel mode
371, 3, context saved
374, 1, find vector 7 in memory position 0x000e
375, 1, load address 0X00BD into the PC
376, 43, SYSCALL: run the ISR
419, 86, transfer data
505, 13, check for errors
518, 1, IRET
519, 45, CPU
564, 55, CPU
619, 70, CPU
689, 1, switch to kernel mode
690, 3, context saved
693, 1, find vector 5 in memory position 0x000a
694, 1, load address 0X048B into the PC
695, 33, SYSCALL: run the ISR
728, 66, transfer data
794, 13, check for errors
807, 1, IRET

Save Time: 0 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
+--------------------------------------------+

Save Time: 17 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
| 1   | init        | 6                | 1    |
+--------------------------------------------+

Save Time: 74 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
| 1   | program1    | 5                | 5    |
+--------------------------------------------+

Save Time: 91 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
| 1   | program1    | 5                | 5    |
| 2   | program1    | 5                | 5    |
+--------------------------------------------+

Save Time: 148 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
| 1   | program1    | 5                | 5    |
| 2   | program2    | 4                | 9    |
+--------------------------------------------+

Save Time: 165 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
| 1   | program1    | 5                | 5    |
| 2   | program2    | 4                | 9    |
| 3   | program2    | 4                | 9    |
+--------------------------------------------+

Save Time: 222 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
| 1   | program1    | 5                | 5    |
| 2   | program2    | 4                | 9    |
| 3   | program3    | 3                | 14   |
+--------------------------------------------+

Save Time: 239 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
| 1   | program1    | 5                | 5    |
| 2   | program2    | 4                | 9    |
| 3   | program3    | 3                | 14   |
| 4   | program3    | 3                | 14   |
+--------------------------------------------+

Save Time: 296 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
| 1   | program1    | 5                | 5    |
| 2   | program2    | 4                | 9    |
| 3   | program3    | 3                | 14   |
| 4   | program4    | 2                | 19   |
+--------------------------------------------+

Save Time: 313 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
| 1   | program1    | 5                | 5    |
| 2   | program2    | 4                | 9    |
| 3   | program3    | 3                | 14   |
| 4   | program4    | 2                | 19   |
| 5   | program4    | 2                | 19   |
+--------------------------------------------+

Save Time: 370 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
| 1   | program1    | 5                | 5    |
| 2   | program2    | 4                | 9    |
| 3   | program3    | 3                | 14   |
| 4   | program4    | 2                | 19   |
| 5   | program5    | 1                | 24   |
+--------------------------------------------+
FORK, 14
EXEC program4, 32
END_IO 9, 160FORK, 15
EXEC program5, 40
CPU, 550X01E3
0X029C
0X0695
0X042B
0X0292
0X048B
0X0639
0X00BD
0X06EF
0X036C
0X07B0
0X01F8
0X03B9
0X06C7
0X0165
0X0584
0X02DF
0X05B3
0X060A
0X0765
0X07B7
0X0523
0X03B7
0X028C
0X05E8
0X05D3
program1, 5
program2, 9
program3, 14
program4, 19
program5, 24FORK, 11
EXEC program1, 30SYSCALL 4, 125CPU, 1000, 1, switch to kernel mode
1, 3, context saved
4, 1, find vector 2 in memory position 0x0004
5, 1, load address 0X0695 into the PC
6, 8, FORK: copy parent PCB to child PCB
14, 2, scheduler called
16, 1, IRET
17, 1, switch to kernel mode
18, 3, context saved
21, 1, find vector 3 in memory position 0x0006
22, 1, load address 0X042B into the PC
23, 30, EXEC: load program1 of size 10Mb
53, 10, found partition 4 with 10Mb of space
63, 6, partition 4 marked as occupied
69, 2, updating PCB with new information
71, 2, scheduler called
73, 1, IRET
74, 100, CPU
174, 1, switch to kernel mode
175, 3, context saved
178, 1, find vector 2 in memory position 0x0004
179, 1, load address 0X0695 into the PC
180, 8, FORK: copy parent PCB to child PCB
188, 2, scheduler called
190, 1, IRET
191, 1, switch to kernel mode
192, 3, context saved
195, 1, find vector 3 in memory position 0x0006
196, 1, load address 0X042B into the PC
197, 30, EXEC: load program2 of size 15Mb
227, 10, found partition 3 with 15Mb of space
237, 6, partition 3 marked as occupied
243, 2, updating PCB with new information
245, 2, scheduler called
247, 1, IRET
248, 1, switch to kernel mode
249, 3, context saved
252, 1, find vector 4 in memory position 0x0008
253, 1, load address 0X0292 into the PC
254, 41, SYSCALL: run the ISR
295, 83, transfer data
378, 13, check for errors
391, 1, IRET
!-----------------------------------------------------------!
Save Time: 0 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
+--------------------------------------------+
!-----------------------------------------------------------!

!-----------------------------------------------------------!
Save Time: 17 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
| 1   | init        | 6                | 1    |
+--------------------------------------------+
!-----------------------------------------------------------!

!-----------------------------------------------------------!
Save Time: 74 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
| 1   | program1    | 4                | 10   |
+--------------------------------------------+
!-----------------------------------------------------------!

!-----------------------------------------------------------!
Save Time: 191 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
| 1   | program1    | 4                | 10   |
| 2   | program1    | 4                | 10   |
+--------------------------------------------+
!-----------------------------------------------------------!

!-----------------------------------------------------------!
Save Time: 248 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
| 1   | program1    | 4                | 10   |
| 2   | program2    | 3                | 15   |
+--------------------------------------------+
!-----------------------------------------------------------!

0X01E3
0X029C
0X0695
0X042B
0X0292
0X048B
0X0639
0X00BD
0X06EF
0X036C
0X07B0
0X01F8
0X03B9
0X06C7
0X0165
0X0584
0X02DF
0X05B3
0X060A
0X0765
0X07B7
0X0523
0X03B7
0X028C
0X05E8
0X05D3
program1, 10
program2, 15FORK, 10
EXEC program1, 50
FORK, 15
EXEC program2, 25FORK, 13
EXEC program3, 42
SYSCALL 7, 150FORK, 14
EXEC program2, 35
CPU, 800, 1, switch to kernel mode
1, 3, context saved
4, 1, find vector 2 in memory position 0x0004
5, 1, load address 0X0695 into the PC
6, 8, FORK: copy parent PCB to child PCB
14, 2, scheduler called
16, 1, IRET
17, 1, switch to kernel mode
18, 3, context saved
21, 1, find vector 3 in memory position 0x0006
22, 1, load address 0X042B into the PC
23, 30, EXEC: load program1 of size 8Mb
53, 10, found partition 5 with 8Mb of space
63, 6, partition 5 marked as occupied
69, 2, updating PCB with new information
71, 2, scheduler called
73, 1, IRET
74, 1, switch to kernel mode
75, 3, context saved
78, 1, find vector 2 in memory position 0x0004
79, 1, load address 0X0695 into the PC
80, 8, FORK: copy parent PCB to child PCB
88, 2, scheduler called
90, 1, IRET
91, 1, switch to kernel mode
92, 3, context saved
95, 1, find vector 3 in memory position 0x0006
96, 1, load address 0X042B into the PC
97, 30, EXEC: load program2 of size 12Mb
127, 10, found partition 3 with 15Mb of space
137, 6, partition 3 marked as occupied
143, 2, updating PCB with new information
145, 2, scheduler called
147, 1, IRET
148, 1, switch to kernel mode
149, 3, context saved
152, 1, find vector 2 in memory position 0x0004
153, 1, load address 0X0695 into the PC
154, 8, FORK: copy parent PCB to child PCB
162, 2, scheduler called
164, 1, IRET
165, 1, switch to kernel mode
166, 3, context saved
169, 1, find vector 3 in memory position 0x0006
170, 1, load address 0X042B into the PC
171, 30, EXEC: load program3 of size 18Mb
201, 10, found partition 2 with 25Mb of space
211, 6, partition 2 marked as occupied
217, 2, updating PCB with new information
219, 2, scheduler called
221, 1, IRET
222, 1, switch to kernel mode
223, 3, context saved
226, 1, find vector 2 in memory position 0x0004
227, 1, load address 0X0695 into the PC
228, 8, FORK: copy parent PCB to child PCB
236, 2, scheduler called
238, 1, IRET
239, 1, switch to kernel mode
240, 3, context saved
243, 1, find vector 3 in memory position 0x0006
244, 1, load address 0X042B into the PC
245, 30, EXEC: load program4 of size 22Mb
275, 10, found partition 1 with 40Mb of space
285, 6, partition 1 marked as occupied
291, 2, updating PCB with new information
293, 2, scheduler called
295, 1, IRET
296, 60, CPU
356, 1, switch to kernel mode
357, 3, context saved
360, 1, find vector 8 in memory position 0x0010
361, 1, load address 0X06EF into the PC
362, 46, SYSCALL: run the ISR
408, 93, transfer data
501, 13, check for errors
514, 1, IRET
515, 25, CPU
540, 1, switch to kernel mode
541, 3, context saved
544, 1, find vector 7 in memory position 0x000e
545, 1, load address 0X00BD into the PC
546, 50, SYSCALL: run the ISR
596, 100, transfer data
696, 13, check for errors
709, 1, IRET
710, 80, CPU

Save Time: 0 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
+--------------------------------------------+

Save Time: 17 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
| 1   | init        | 6                | 1    |
+--------------------------------------------+

Save Time: 74 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
| 1   | program1    | 5                | 8    |
+--------------------------------------------+

Save Time: 91 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
| 1   | program1    | 5                | 8    |
| 2   | program1    | 5                | 8    |
+--------------------------------------------+

Save Time: 148 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
| 1   | program1    | 5                | 8    |
| 2   | program2    | 3                | 12   |
+--------------------------------------------+

Save Time: 165 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
| 1   | program1    | 5                | 8    |
| 2   | program2    | 3                | 12   |
| 3   | program2    | 3                | 12   |
+--------------------------------------------+

Save Time: 222 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
| 1   | program1    | 5                | 8    |
| 2   | program2    | 3                | 12   |
| 3   | program3    | 2                | 18   |
+--------------------------------------------+

Save Time: 239 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
| 1   | program1    | 5                | 8    |
| 2   | program2    | 3                | 12   |
| 3   | program3    | 2                | 18   |
| 4   | program3    | 2                | 18   |
+--------------------------------------------+

Save Time: 296 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
| 1   | program1    | 5                | 8    |
| 2   | program2    | 3                | 12   |
| 3   | program3    | 2                | 18   |
| 4   | program4    | 1                | 22   |
+--------------------------------------------+
FORK, 15
EXEC program4, 38
END_IO 12, 180CPU, 60
SYSCALL 8, 140
CPU, 250X01E3
0X029C
0X0695
0X042B
0X0292
0X048B
0X0639
0X00BD
0X06EF
0X036C
0X07B0
0X01F8
0X03B9
0X06C7
0X0165
0X0584
0X02DF
0X05B3
0X060A
0X0765
0X07B7
0X0523
0X03B7
0X028C
0X05E8
0X05D3
program1, 8
program2, 12
program3, 18
program4, 22FORK, 12
EXEC program1, 40CPU, 50
SYSCALL 4, 2500, 1, switch to kernel mode
1, 3, context saved
4, 1, find vector 2 in memory position 0x0004
5, 1, load address 0X0695 into the PC
6, 8, FORK: copy parent PCB to child PCB
14, 2, scheduler called
16, 1, IRET
17, 1, switch to kernel mode
18, 3, context saved
21, 1, find vector 3 in memory position 0x0006
22, 1, load address 0X042B into the PC
23, 30, EXEC: load program1 of size 10Mb
53, 10, found partition 4 with 10Mb of space
63, 6, partition 4 marked as occupied
69, 2, updating PCB with new information
71, 2, scheduler called
73, 1, IRET
74, 50, CPU
124, 1, switch to kernel mode
125, 3, context saved
128, 1, find vector 4 in memory position 0x0008
129, 1, load address 0X0292 into the PC
130, 83, SYSCALL: run the ISR
213, 166, transfer data
379, 13, check for errors
392, 1, IRET
!-----------------------------------------------------------!
Save Time: 0 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
+--------------------------------------------+
!-----------------------------------------------------------!

!-----------------------------------------------------------!
Save Time: 17 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
| 1   | init        | 6                | 1    |
+--------------------------------------------+
!-----------------------------------------------------------!

!-----------------------------------------------------------!
Save Time: 74 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
| 1   | program1    | 4                | 10   |
+--------------------------------------------+
!-----------------------------------------------------------!

0X01E3
0X029C
0X0695
0X042B
0X0292
0X048B
0X0639
0X00BD
0X06EF
0X036C
0X07B0
0X01F8
0X03B9
0X06C7
0X0165
0X0584
0X02DF
0X05B3
0X060A
0X0765
0X07B7
0X0523
0X03B7
0X028C
0X05E8
0X05D3
program1, 10
FORK, 20 
EXEC program1, 60FORK, 16
EXEC program3, 58FORK, 17
EXEC program2, 460, 1, switch to kernel mode
1, 3, context saved
4, 1, find vector 2 in memory position 0x0004
5, 1, load address 0X0695 into the PC
6, 8, FORK: copy parent PCB to child PCB
14, 2, scheduler called
16, 1, IRET
17, 1, switch to kernel mode
18, 3, context saved
21, 1, find vector 3 in memory position 0x0006
22, 1, load address 0X042B into the PC
23, 30, EXEC: load program1 of size 10Mb
53, 10, found partition 4 with 10Mb of space
63, 6, partition 4 marked as occupied
69, 2, updating PCB with new information
71, 2, scheduler called
73, 1, IRET
74, 1, switch to kernel mode
75, 3, context saved
78, 1, find vector 2 in memory position 0x0004
79, 1, load address 0X0695 into the PC
80, 8, FORK: copy parent PCB to child PCB
88, 2, scheduler called
90, 1, IRET
91, 1, switch to kernel mode
92, 3, context saved
95, 1, find vector 3 in memory position 0x0006
96, 1, load address 0X042B into the PC
97, 30, EXEC: load program2 of size 15Mb
127, 10, found partition 3 with 15Mb of space
137, 6, partition 3 marked as occupied
143, 2, updating PCB with new information
145, 2, scheduler called
147, 1, IRET
148, 1, switch to kernel mode
149, 3, context saved
152, 1, find vector 2 in memory position 0x0004
153, 1, load address 0X0695 into the PC
154, 8, FORK: copy parent PCB to child PCB
162, 2, scheduler called
164, 1, IRET
165, 1, switch to kernel mode
166, 3, context saved
169, 1, find vector 3 in memory position 0x0006
170, 1, load address 0X042B into the PC
171, 30, EXEC: load program3 of size 20Mb
201, 10, found partition 2 with 25Mb of space
211, 6, partition 2 marked as occupied
217, 2, updating PCB with new information
219, 2, scheduler called
221, 1, IRET
222, 50, CPU
272, 1, switch to kernel mode
273, 3, context saved
276, 1, find vector 6 in memory position 0x000c
277, 1, load address 0X0639 into the PC
278, 36, SYSCALL: run the ISR
314, 73, transfer data
387, 13, check for errors
400, 1, IRET
401, 15, CPU

Save Time: 0 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
+--------------------------------------------+

Save Time: 17 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
| 1   | init        | 6                | 1    |
+--------------------------------------------+

Save Time: 74 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
| 1   | program1    | 4                | 10   |
+--------------------------------------------+

Save Time: 91 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
| 1   | program1    | 4                | 10   |
| 2   | program1    | 4                | 10   |
+--------------------------------------------+

Save Time: 148 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
| 1   | program1    | 4                | 10   |
| 2   | program2    | 3                | 15   |
+--------------------------------------------+

Save Time: 165 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
| 1   | program1    | 4                | 10   |
| 2   | program2    | 3                | 15   |
| 3   | program2    | 3                | 15   |
+--------------------------------------------+

Save Time: 222 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
| 1   | program1    | 4                | 10   |
| 2   | program2    | 3                | 15   |
| 3   | program3    | 2                | 20   |
+--------------------------------------------+
CPU, 50
SYSCALL 6, 110
CPU, 15
END_IO 10, 2200X01E3
0X029C
0X0695
0X042B
0X0292
0X048B
0X0639
0X00BD
0X06EF
0X036C
0X07B0
0X01F8
0X03B9
0X06C7
0X0165
0X0584
0X02DF
0X05B3
0X060A
0X0765
0X07B7
0X0523
0X03B7
0X028C
0X05E8
0X05D3
program1, 10
program2, 15
program3, 20FORK, 20
EXEC program1, 60./"interrupts" ../tests/1/
./"interrupts" ../tests/2/
./"interrupts" ../tests/3/
./"interrupts" ../tests/4/
./"interrupts" ../tests/5/#include "interrupts.hpp"

// Define memory partitions
std::vector<MemoryPartition> memory_partitions = {
    {1, 40, "free"}, {2, 25, "free"}, {3, 15, "free"},
    {4, 10, "free"}, {5, 8, "free"}, {6, 2, "occupied"}
};
std::vector<PCB> pcb_table;
std::vector<ExternalFile> external_files;
std::map<int, std::string> vector_table;

unsigned int current_pid = 0;
int current_time = 0;

std::string execution_log;

// Helper function to split a string by a delimiter
std::vector<std::string> split_delim(const std::string& s, const std::string& delimiter) {
    std::vector<std::string> tokens;
    size_t last = 0;
    size_t next = 0;
    while ((next = s.find(delimiter, last)) != std::string::npos) {
        tokens.push_back(s.substr(last, next - last));
        last = next + 1;
    }
    tokens.push_back(s.substr(last));
    return tokens;
}

// Load external files from a given file path
void load_external_files(const std::string& file_path) {
    std::ifstream file(file_path);
    std::string line;
        if (!file.is_open()) {
        throw std::runtime_error("Failed to open file: " + file_path);
    }
    while (std::getline(file, line)) {
        auto parts = split_delim(line, ",");
        if (parts.size() == 2) {
            external_files.push_back({parts[0], static_cast<unsigned int>(std::stoi(parts[1]))});
        }
    }
}

// Load vector table from a given file path
void load_vector_table(const std::string& file_path) {
    std::ifstream file(file_path);
    std::string line;
    int vector_num = 0;
    while (std::getline(file, line)) {
        vector_table[vector_num] = line;
        vector_num++;
    }
}

// Initialize the Process Control Block (PCB)
void init_pcb() {
    pcb_table.push_back({current_pid, "init", 6, 1, 0, "Ready"});
}

// Log a step in the execution process
void log_step(const std::string& step, int duration) {
    execution_log += std::to_string(current_time) + ", " + std::to_string(duration) + ", " + step + "\n";
    current_time += duration;
}

// Simulate a system call
void simulate_syscall(int vector_num) {
    log_step("switch to kernel mode", 1);
    log_step("context saved", 3);
    std::stringstream ss;
    ss << "find vector " << vector_num << " in memory position 0x" 
       << std::setfill('0') << std::setw(4) << std::hex << (ADDR_BASE + (vector_num * VECTOR_SIZE));
    log_step(ss.str(), 1);
    log_step("load address " + vector_table[vector_num] + " into the PC", 1);
}

// Save the current system status to a file
void save_system_status(const std::string& output_file_path) {
    std::ofstream output_file(output_file_path, std::ios::app);
    output_file << "\nSave Time: " << current_time << " ms\n";
    output_file << "+--------------------------------------------+\n";
    output_file << "| PID |Program Name |Partition Number | size |\n";
    output_file << "+--------------------------------------------+\n";
    for (const auto& pcb : pcb_table) {
        output_file << "| " << std::setw(3) << pcb.pid << " | " 
                    << std::setw(11) << std::left << pcb.name << " | " 
                    << std::setw(16) << std::left << pcb.partition << " | " 
                    << std::setw(4) << std::left << pcb.size << " |\n";
    }
    output_file << "+--------------------------------------------+\n";
}

// Simulate the fork system call
void simulate_fork(const std::string& output_directory) {
    simulate_syscall(2);
    log_step("FORK: copy parent PCB to child PCB", 8);
    
    PCB parent = pcb_table.back();
    PCB child = parent;
    child.pid = ++current_pid;
    child.state = "Ready";
    pcb_table.push_back(child);

    log_step("scheduler called", 2);
    log_step("IRET", 1);
    
    save_system_status(output_directory + "/system_status.txt");
}

// Simulate the exec system call
void simulate_exec(const std::string& program_name, const std::string& output_directory) {
    simulate_syscall(3);
    
    auto it = std::find_if(external_files.begin(), external_files.end(),
                           [&](const ExternalFile& ef) { return ef.name == program_name; });

    unsigned int program_size = it->size;
    log_step("EXEC: load " + program_name + " of size " + std::to_string(program_size) + "Mb", 30);

    // Find a suitable memory partition
    auto partition_it = std::min_element(memory_partitions.begin(), memory_partitions.end(),
                                         [&](const MemoryPartition& a, const MemoryPartition& b) {
                                             return (a.status == "free" && a.size >= program_size && a.size < b.size) ||
                                                    (b.status != "free" || b.size < program_size);
                                         });

    log_step("found partition " + std::to_string(partition_it->number) + " with " + std::to_string(partition_it->size) + "Mb of space", 10);
    log_step("partition " + std::to_string(partition_it->number) + " marked as occupied", 6);

    partition_it->status = "occupied";
    
    PCB& current_pcb = pcb_table.back();
    current_pcb.name = program_name;
    current_pcb.partition = partition_it->number;
    current_pcb.size = program_size;

    log_step("updating PCB with new information", 2);
    log_step("scheduler called", 2);
    log_step("IRET", 1);
    
    save_system_status(output_directory + "/system_status.txt");
}

// Simulate CPU execution
void simulate_cpu(int duration) {
    log_step("CPU", duration);
}

// Simulate a general system call
void simulate_syscall(int syscall_num, int duration) {
    simulate_syscall(syscall_num);
    log_step("SYSCALL: run the ISR", duration / 3);
    log_step("transfer data", (duration * 2) / 3);
    log_step("check for errors", 13);
    log_step("IRET", 1);
}

// Execute a program
void execute_program(const std::string& program_name, const std::string& output_directory, const std::string& input_directory) {
    std::string program_file = input_directory + "/" + program_name + ".txt";
    std::ifstream program(program_file);

    std::string line;
    while (std::getline(program, line)) {
        auto parts = split_delim(line, ",");
        if (parts.empty()) continue;

        if (parts[0] == "FORK") {
            simulate_fork(output_directory);
        } else if (parts[0].substr(0, 4) == "EXEC") {
            auto exec_parts = split_delim(parts[0], " ");
            if (exec_parts.size() >= 2) {
                simulate_exec(exec_parts[1], output_directory);
                execute_program(exec_parts[1], output_directory, input_directory);
            }
        } else if (parts[0] == "CPU") {
            if (parts.size() >= 2) {
                simulate_cpu(std::stoi(parts[1]));
            }
        } else if (parts[0].substr(0, 7) == "SYSCALL") {
            auto syscall_parts = split_delim(parts[0], " ");
            if (syscall_parts.size() >= 2 && parts.size() >= 2) {
                simulate_syscall(std::stoi(syscall_parts[1]), std::stoi(parts[1]));
            }
        }
    }
}

// Process the trace file
void process_trace(const std::string& trace_file_path, const std::string& output_directory,  const std::string& input_directory) {
    std::ifstream trace_file(trace_file_path);
    std::string line;
    while (std::getline(trace_file, line)) {
        auto parts = split_delim(line, ",");
        if (parts.empty()) continue;
        
        if (parts[0] == "FORK") {
            simulate_fork(output_directory);
        } else if (parts[0].substr(0, 4) == "EXEC") {
            auto exec_parts = split_delim(parts[0], " ");
            if (exec_parts.size() >= 2) {
                simulate_exec(exec_parts[1], output_directory);
                execute_program(exec_parts[1], output_directory, input_directory);
            }
        } else if (parts[0] == "CPU") {
            if (parts.size() >= 2) {
                simulate_cpu(std::stoi(parts[1]));
            }
        } else if (parts[0].substr(0, 7) == "SYSCALL") {
            auto syscall_parts = split_delim(parts[0], " ");
            if (syscall_parts.size() >= 2 && parts.size() >= 2) {
                simulate_syscall(std::stoi(syscall_parts[1]), std::stoi(parts[1]));
            }
        }
    }
}

int main(int argc, char** argv) {
    if (argc != 2) {
        std::cerr << "Usage: " << argv[0] << " <PATH TO INPUT DIRECTORY>" << std::endl;
        return 1;
    }

    std::string input_directory(argv[1]);
    std::string output_directory = input_directory + "/outputs";
    mkdir(output_directory.c_str(), 0777);

    // Delete existing output files if they exist
    std::string system_status_file = output_directory + "/system_status.txt";
    std::string execution_file = output_directory + "/execution.txt";
    std::remove(system_status_file.c_str());
    std::remove(execution_file.c_str());

    // Load necessary data
    load_external_files(input_directory + "/external_files.txt");
    load_vector_table(input_directory + "/vector_table.txt");
    init_pcb();

    // Save initial system status
    save_system_status(system_status_file);

    // Process the trace file
    process_trace(input_directory + "/trace.txt", output_directory, input_directory);

    // Write execution log to file
    std::ofstream execution_output(execution_file);
    if (execution_output.is_open()) {
        execution_output << execution_log;
        execution_output.close();
    } else {
        std::cerr << "Error opening file for writing: " << execution_file << std::endl;
    }

    std::cout << "Output generated in " << output_directory << std::endl;
    return 0;
}SYSCALL 4, 125CPU, 1000, 1, switch to kernel mode
1, 7, context saved
8, 1, find vector 2 in memory position 0x0008
9, 1, load address 0X0695 into the PC
10, 4, FORK: copy parent PCB to child PCB
14, 9, scheduler called
23, 1, IRET
24, 1, switch to kernel mode
25, 7, context saved
32, 1, find vector 3 in memory position 0x000c
33, 1, load address 0X042B into the PC
34, 8, EXEC: load program1 of size 10Mb
42, 4, found partition 1 with 40Mb of space
46, 4, partition 1 marked as occupied
50, 1, updating PCB with new information
51, 5, scheduler called
56, 1, IRET
57, 1, switch to kernel mode
58, 3, context saved
61, 1, find vector 2 in memory position 0x0008
62, 1, load address 0X0695 into the PC
63, 5, FORK: copy parent PCB to child PCB
68, 4, scheduler called
72, 1, IRET
73, 1, switch to kernel mode
74, 7, context saved
81, 1, find vector 3 in memory position 0x000c
82, 1, load address 0X042B into the PC
83, 4, EXEC: load program2 of size 15Mb
87, 10, found partition 2 with 25Mb of space
97, 4, partition 2 marked as occupied
101, 6, updating PCB with new information
107, 6, scheduler called
113, 1, IRET
!-----------------------------------------------------------!
Save Time: 0 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
+--------------------------------------------+
!-----------------------------------------------------------!

!-----------------------------------------------------------!
Save Time: 114 ms
+--------------------------------------------+
| PID |Program Name |Partition Number | size |
+--------------------------------------------+
|   0 | init        | 6                | 1    |
| 1   | program1    | 1                | 10   |
| 2   | program2    | 2                | 15   |
+--------------------------------------------+
!-----------------------------------------------------------!

0X01E3
0X029C
0X0695
0X042B
0X0292
0X048B
0X0639
0X00BD
0X06EF
0X036C
0X07B0
0X01F8
0X03B9
0X06C7
0X0165
0X0584
0X02DF
0X05B3
0X060A
0X0765
0X07B7
0X0523
0X03B7
0X028C
0X05E8
0X05D3
program1, 10
program2, 15FORK, 10
EXEC program1, 50
FORK, 15
EXEC program2, 25./"interrupts" ../tests/1/
./"interrupts" ../tests/2/
./"interrupts" ../tests/3/
./"interrupts" ../tests/4/
./"interrupts" ../tests/5/0, 35, CPU execution
35, 2, switch to kernel mode and context saved
37, 1, find vector 2 in memory position 0x0004
38, 1, load address 0X004F into the PC
39, 46, SYSCALL: run the ISR
85, 46, transfer data
131, 23, check for errors
154, 3, IRET and context restored
157, 30, CPU execution
187, 1, check priority of interrupt
188, 1, check if masked
189, 2, switch to kernel mode and context saved
191, 1, find vector 5 in memory position 0x000A
192, 1, load address 0X0069 into the PC
193, 242, END_IO
435, 3, IRET and context restored
438, 80, CPU execution

Performance Metrics:
Total Execution Time: 518
Total Context Switches: 2
Total ISR Executions: 2
Time Spent on Vector Table Lookups: 2
Time Spent in Interrupt Handling: 311
Time Spent in CPU Operations: 145
Time Spent in I/O Operations: 46
Total Context Switch Time: 10
Total Syscall Time: 122
Total ISR Execution Time: 357
CPU Utilization: 27.99%
Average I/O Response Time: 0.00
Ratio of CPU to I/O Time: 3.15
System Throughput: 0.00 ISRs per time unit
min_context_time: 1
max_context_time: 3
0, 35, CPU execution
35, 3, switch to kernel mode and context saved
38, 1, find vector 2 in memory position 0x0004
39, 1, load address 0X004F into the PC
40, 45, SYSCALL: run the ISR
85, 45, transfer data
130, 24, check for errors
154, 3, IRET and context restored
157, 30, CPU execution
187, 1, check priority of interrupt
188, 1, check if masked
189, 2, switch to kernel mode and context saved
191, 1, find vector 5 in memory position 0x000A
192, 1, load address 0X0069 into the PC
193, 242, END_IO
435, 2, IRET and context restored
437, 80, CPU execution

Performance Metrics:
Total Execution Time: 517
Total Context Switches: 2
Total ISR Executions: 2
Time Spent on Vector Table Lookups: 2
Time Spent in Interrupt Handling: 311
Time Spent in CPU Operations: 145
Time Spent in I/O Operations: 45
Total Context Switch Time: 10
CPU Utilization: 28.05%
Average I/O Response Time: 0.00
Ratio of CPU to I/O Time: 3.22
System Throughput: 0.00 ISRs per time unit
min_context_time: 1
max_context_time: 3
0x02FF
0x0A3D
0x004F
0x0030
0x01AA
0x00690, 35, CPU execution
35, 2, switch to kernel mode and context saved
37, 1, find vector 2 in memory position 0x0004
38, 1, load address 0X004F into the PC
39, 46, SYSCALL: run the ISR
85, 46, transfer data
131, 23, check for errors
154, 1, IRET and context restored
155, 30, CPU execution
185, 1, check priority of interrupt
186, 1, check if masked
187, 1, switch to kernel mode and context saved
188, 1, find vector 5 in memory position 0x000A
189, 1, load address 0X0069 into the PC
190, 243, END_IO
433, 3, IRET and context restored
436, 80, CPU execution

Performance Metrics:
Total Execution Time: 516
Total Context Switches: 2
Total ISR Executions: 2
Time Spent on Vector Table Lookups: 2
Time Spent in Interrupt Handling: 312
Time Spent in CPU Operations: 145
Time Spent in I/O Operations: 46
Total Context Switch Time: 7
CPU Utilization: 28.10%
Average I/O Response Time: 0.00
Ratio of CPU to I/O Time: 3.15
System Throughput: 0.00 ISRs per time unit
min_context_time: 1
max_context_time: 3
CPU, 35
SYSCALL 2, 119
CPU, 30
END_IO 5, 248
CPU, 80CPU, 50
SYSCALL 7, 100
CPU, 30
END_IO 20, 150
CPU, 40
SYSCALL 12, 120
CPU, 60
END_IO 22, 180
CPU, 70
SYSCALL 5, 110
CPU, 44
END_IO 18, 160CPU, 12
SYSCALL 7, 100
CPU, 7
END_IO 20, 150
CPU, 10
SYSCALL 12, 120
CPU, 15
END_IO 22, 180
CPU, 17
SYSCALL 5, 110
CPU, 11
END_IO 18, 1600X03C6
0X0657
0X0707
0X059D
0X04F1
0X0642
0X0191
0X0218
0X05AB
0X0748
0X045E
0X0181
0X064A
0X0271
0X0436
0X0339
0X02C5
0X0555
0X054B
0X009B
0X0531
0X05BE
0X0620
0X03DF
0X01CF#!/bin/bash

# Change to the Part2 directory
cd ./Assignment1/Part2

./interrupts "simulations/cpu_speed/trace_full_speed.txt" "simulations/cpu_speed/vector_table.txt" "simulations/cpu_speed/output/execution_full.txt" 
./interrupts "simulations/cpu_speed/trace_half_speed.txt" "simulations/cpu_speed/vector_table.txt" "simulations/cpu_speed/output/execution_half.txt" 
./interrupts "simulations/cpu_speed/trace_quarter_speed.txt" "simulations/cpu_speed/vector_table.txt" "simulations/cpu_speed/output/execution_quarter.txt"CPU, 25
SYSCALL 7, 100
CPU, 15
END_IO 20, 150
CPU, 20
SYSCALL 12, 120
CPU, 30
END_IO 22, 180
CPU, 35
SYSCALL 5, 110
CPU, 22
END_IO 18, 1600, 50, CPU execution
50, 1, switch to kernel mode and context saved
51, 1, find vector 7 in memory position 0x000e
52, 1, load address 0X0218 into the PC
53, 38, SYSCALL: run the ISR
91, 38, transfer data
129, 21, check for errors
150, 3, IRET and context restored
153, 30, CPU execution
183, 1, check priority of interrupt
184, 1, check if masked
185, 3, switch to kernel mode and context saved
188, 1, find vector 20 in memory position 0x0028
189, 1, load address 0X0531 into the PC
190, 143, END_IO
333, 3, IRET and context restored
336, 40, CPU execution
376, 2, switch to kernel mode and context saved
378, 1, find vector 12 in memory position 0x0018
379, 1, load address 0X064A into the PC
380, 46, SYSCALL: run the ISR
426, 46, transfer data
472, 24, check for errors
496, 1, IRET and context restored
497, 60, CPU execution
557, 1, check priority of interrupt
558, 1, check if masked
559, 1, switch to kernel mode and context saved
560, 1, find vector 22 in memory position 0x002C
561, 1, load address 0X0620 into the PC
562, 175, END_IO
737, 2, IRET and context restored
739, 70, CPU execution
809, 1, switch to kernel mode and context saved
810, 1, find vector 5 in memory position 0x000A
811, 1, load address 0X0642 into the PC
812, 42, SYSCALL: run the ISR
854, 42, transfer data
896, 23, check for errors
919, 1, IRET and context restored
920, 44, CPU execution
964, 1, check priority of interrupt
965, 1, check if masked
966, 3, switch to kernel mode and context saved
969, 1, find vector 18 in memory position 0x0024
970, 1, load address 0X054B into the PC
971, 153, END_IO
1124, 2, IRET and context restored

Performance Metrics:
Total Execution Time: 1126
Total Context Switches: 6
Total ISR Executions: 6
Time Spent on Vector Table Lookups: 6
Time Spent in Interrupt Handling: 665
Time Spent in CPU Operations: 294
Time Spent in I/O Operations: 126
Total Context Switch Time: 23
Total Syscall Time: 335
Total ISR Execution Time: 791
CPU Utilization: 26.11%
Average I/O Response Time: 0.00
Ratio of CPU to I/O Time: 2.33
System Throughput: 0.01 ISRs per time unit
Number of I/O Operations: 0
Average Syscall Time: 55.83
Average ISR Execution Time: 131.83
min_context_time: 1
max_context_time: 3
0, 25, CPU execution
25, 2, switch to kernel mode and context saved
27, 1, find vector 7 in memory position 0x000e
28, 1, load address 0X0218 into the PC
29, 38, SYSCALL: run the ISR
67, 38, transfer data
105, 20, check for errors
125, 3, IRET and context restored
128, 15, CPU execution
143, 1, check priority of interrupt
144, 1, check if masked
145, 1, switch to kernel mode and context saved
146, 1, find vector 20 in memory position 0x0028
147, 1, load address 0X0531 into the PC
148, 145, END_IO
293, 2, IRET and context restored
295, 20, CPU execution
315, 3, switch to kernel mode and context saved
318, 1, find vector 12 in memory position 0x0018
319, 1, load address 0X064A into the PC
320, 46, SYSCALL: run the ISR
366, 46, transfer data
412, 23, check for errors
435, 2, IRET and context restored
437, 30, CPU execution
467, 1, check priority of interrupt
468, 1, check if masked
469, 3, switch to kernel mode and context saved
472, 1, find vector 22 in memory position 0x002C
473, 1, load address 0X0620 into the PC
474, 173, END_IO
647, 3, IRET and context restored
650, 35, CPU execution
685, 3, switch to kernel mode and context saved
688, 1, find vector 5 in memory position 0x000A
689, 1, load address 0X0642 into the PC
690, 42, SYSCALL: run the ISR
732, 42, transfer data
774, 21, check for errors
795, 2, IRET and context restored
797, 22, CPU execution
819, 1, check priority of interrupt
820, 1, check if masked
821, 2, switch to kernel mode and context saved
823, 1, find vector 18 in memory position 0x0024
824, 1, load address 0X054B into the PC
825, 154, END_IO
979, 3, IRET and context restored

Performance Metrics:
Total Execution Time: 982
Total Context Switches: 6
Total ISR Executions: 6
Time Spent on Vector Table Lookups: 6
Time Spent in Interrupt Handling: 662
Time Spent in CPU Operations: 147
Time Spent in I/O Operations: 126
Total Context Switch Time: 29
Total Syscall Time: 337
Total ISR Execution Time: 788
CPU Utilization: 14.97%
Average I/O Response Time: 0.00
Ratio of CPU to I/O Time: 1.17
System Throughput: 0.01 ISRs per time unit
Number of I/O Operations: 0
Average Syscall Time: 56.17
Average ISR Execution Time: 131.33
min_context_time: 1
max_context_time: 3
0, 12, CPU execution
12, 3, switch to kernel mode and context saved
15, 1, find vector 7 in memory position 0x000e
16, 1, load address 0X0218 into the PC
17, 38, SYSCALL: run the ISR
55, 38, transfer data
93, 19, check for errors
112, 2, IRET and context restored
114, 7, CPU execution
121, 1, check priority of interrupt
122, 1, check if masked
123, 1, switch to kernel mode and context saved
124, 1, find vector 20 in memory position 0x0028
125, 1, load address 0X0531 into the PC
126, 145, END_IO
271, 2, IRET and context restored
273, 10, CPU execution
283, 2, switch to kernel mode and context saved
285, 1, find vector 12 in memory position 0x0018
286, 1, load address 0X064A into the PC
287, 46, SYSCALL: run the ISR
333, 46, transfer data
379, 24, check for errors
403, 1, IRET and context restored
404, 15, CPU execution
419, 1, check priority of interrupt
420, 1, check if masked
421, 1, switch to kernel mode and context saved
422, 1, find vector 22 in memory position 0x002C
423, 1, load address 0X0620 into the PC
424, 175, END_IO
599, 2, IRET and context restored
601, 17, CPU execution
618, 1, switch to kernel mode and context saved
619, 1, find vector 5 in memory position 0x000A
620, 1, load address 0X0642 into the PC
621, 42, SYSCALL: run the ISR
663, 42, transfer data
705, 23, check for errors
728, 2, IRET and context restored
730, 11, CPU execution
741, 1, check priority of interrupt
742, 1, check if masked
743, 1, switch to kernel mode and context saved
744, 1, find vector 18 in memory position 0x0024
745, 1, load address 0X054B into the PC
746, 155, END_IO
901, 3, IRET and context restored

Performance Metrics:
Total Execution Time: 904
Total Context Switches: 6
Total ISR Executions: 6
Time Spent on Vector Table Lookups: 6
Time Spent in Interrupt Handling: 667
Time Spent in CPU Operations: 72
Time Spent in I/O Operations: 126
Total Context Switch Time: 21
Total Syscall Time: 335
Total ISR Execution Time: 793
CPU Utilization: 7.96%
Average I/O Response Time: 0.00
Ratio of CPU to I/O Time: 0.57
System Throughput: 0.01 ISRs per time unit
Number of I/O Operations: 0
Average Syscall Time: 55.83
Average ISR Execution Time: 132.17
min_context_time: 1
max_context_time: 3
0X03C6
0X0657
0X0707
0X059D
0X04F1
0X0642
0X0191
0X0218
0X05AB
0X0748
0X045E
0X0181
0X064A
0X0271
0X0436
0X0339
0X02C5
0X0555
0X054B
0X009B
0X0531
0X05BE
0X0620
0X03DF
0X01CF#!/bin/bash

# Change to the Part2 directory
cd ./Assignment1/Part2

./interrupts "simulations/context_switch/trace.txt" "simulations/context_switch/vector_table.txt" "simulations/context_switch/output/execution_1_3.txt" 1 3
./interrupts "simulations/context_switch/trace.txt" "simulations/context_switch/vector_table.txt" "simulations/context_switch/output/execution_3_5.txt" 3 5
./interrupts "simulations/context_switch/trace.txt" "simulations/context_switch/vector_table.txt" "simulations/context_switch/output/execution_5_10.txt" 5 10
./interrupts "simulations/context_switch/trace.txt" "simulations/context_switch/vector_table.txt" "simulations/context_switch/output/execution_10_20.txt" 10 20

CPU, 50
SYSCALL 7, 100
CPU, 30
END_IO 20, 150
CPU, 40
SYSCALL 12, 120
CPU, 60
END_IO 22, 180
CPU, 70
SYSCALL 5, 110
CPU, 45
END_IO 18, 1600, 50, CPU execution
50, 13, switch to kernel mode and context saved
63, 1, find vector 7 in memory position 0x000e
64, 1, load address 0X0218 into the PC
65, 34, SYSCALL: run the ISR
99, 34, transfer data
133, 17, check for errors
150, 10, IRET and context restored
160, 30, CPU execution
190, 1, check priority of interrupt
191, 1, check if masked
192, 17, switch to kernel mode and context saved
209, 1, find vector 20 in memory position 0x0028
210, 1, load address 0X0531 into the PC
211, 129, END_IO
340, 16, IRET and context restored
356, 40, CPU execution
396, 18, switch to kernel mode and context saved
414, 1, find vector 12 in memory position 0x0018
415, 1, load address 0X064A into the PC
416, 40, SYSCALL: run the ISR
456, 40, transfer data
496, 20, check for errors
516, 12, IRET and context restored
528, 60, CPU execution
588, 1, check priority of interrupt
589, 1, check if masked
590, 16, switch to kernel mode and context saved
606, 1, find vector 22 in memory position 0x002C
607, 1, load address 0X0620 into the PC
608, 160, END_IO
768, 10, IRET and context restored
778, 70, CPU execution
848, 14, switch to kernel mode and context saved
862, 1, find vector 5 in memory position 0x000A
863, 1, load address 0X0642 into the PC
864, 37, SYSCALL: run the ISR
901, 37, transfer data
938, 20, check for errors
958, 10, IRET and context restored
968, 45, CPU execution
1013, 1, check priority of interrupt
1014, 1, check if masked
1015, 16, switch to kernel mode and context saved
1031, 1, find vector 18 in memory position 0x0024
1032, 1, load address 0X054B into the PC
1033, 140, END_IO
1173, 10, IRET and context restored

Performance Metrics:
Total Execution Time: 1183
Total Context Switches: 6
Total ISR Executions: 6
Time Spent on Vector Table Lookups: 6
Time Spent in Interrupt Handling: 597
Time Spent in CPU Operations: 295
Time Spent in I/O Operations: 111
Total Context Switch Time: 162
CPU Utilization: 24.94%
Average I/O Response Time: 0.00
Ratio of CPU to I/O Time: 2.66
System Throughput: 0.01 ISRs per time unit
min_context_time: 10
max_context_time: 20
0, 50, CPU execution
50, 4, switch to kernel mode and context saved
54, 1, find vector 7 in memory position 0x000e
55, 1, load address 0X0218 into the PC
56, 37, SYSCALL: run the ISR
93, 37, transfer data
130, 20, check for errors
150, 3, IRET and context restored
153, 30, CPU execution
183, 1, check priority of interrupt
184, 1, check if masked
185, 4, switch to kernel mode and context saved
189, 1, find vector 20 in memory position 0x0028
190, 1, load address 0X0531 into the PC
191, 142, END_IO
333, 4, IRET and context restored
337, 40, CPU execution
377, 3, switch to kernel mode and context saved
380, 1, find vector 12 in memory position 0x0018
381, 1, load address 0X064A into the PC
382, 46, SYSCALL: run the ISR
428, 46, transfer data
474, 23, check for errors
497, 5, IRET and context restored
502, 60, CPU execution
562, 1, check priority of interrupt
563, 1, check if masked
564, 4, switch to kernel mode and context saved
568, 1, find vector 22 in memory position 0x002C
569, 1, load address 0X0620 into the PC
570, 172, END_IO
742, 4, IRET and context restored
746, 70, CPU execution
816, 4, switch to kernel mode and context saved
820, 1, find vector 5 in memory position 0x000A
821, 1, load address 0X0642 into the PC
822, 41, SYSCALL: run the ISR
863, 41, transfer data
904, 22, check for errors
926, 5, IRET and context restored
931, 45, CPU execution
976, 1, check priority of interrupt
977, 1, check if masked
978, 3, switch to kernel mode and context saved
981, 1, find vector 18 in memory position 0x0024
982, 1, load address 0X054B into the PC
983, 153, END_IO
1136, 5, IRET and context restored

Performance Metrics:
Total Execution Time: 1141
Total Context Switches: 6
Total ISR Executions: 6
Time Spent on Vector Table Lookups: 6
Time Spent in Interrupt Handling: 656
Time Spent in CPU Operations: 295
Time Spent in I/O Operations: 124
Total Context Switch Time: 48
CPU Utilization: 25.85%
Average I/O Response Time: 0.00
Ratio of CPU to I/O Time: 2.38
System Throughput: 0.01 ISRs per time unit
min_context_time: 3
max_context_time: 5
0, 50, CPU execution
50, 10, switch to kernel mode and context saved
60, 1, find vector 7 in memory position 0x000e
61, 1, load address 0X0218 into the PC
62, 35, SYSCALL: run the ISR
97, 35, transfer data
132, 18, check for errors
150, 8, IRET and context restored
158, 30, CPU execution
188, 1, check priority of interrupt
189, 1, check if masked
190, 9, switch to kernel mode and context saved
199, 1, find vector 20 in memory position 0x0028
200, 1, load address 0X0531 into the PC
201, 137, END_IO
338, 7, IRET and context restored
345, 40, CPU execution
385, 8, switch to kernel mode and context saved
393, 1, find vector 12 in memory position 0x0018
394, 1, load address 0X064A into the PC
395, 44, SYSCALL: run the ISR
439, 44, transfer data
483, 22, check for errors
505, 7, IRET and context restored
512, 60, CPU execution
572, 1, check priority of interrupt
573, 1, check if masked
574, 7, switch to kernel mode and context saved
581, 1, find vector 22 in memory position 0x002C
582, 1, load address 0X0620 into the PC
583, 169, END_IO
752, 5, IRET and context restored
757, 70, CPU execution
827, 10, switch to kernel mode and context saved
837, 1, find vector 5 in memory position 0x000A
838, 1, load address 0X0642 into the PC
839, 39, SYSCALL: run the ISR
878, 39, transfer data
917, 20, check for errors
937, 8, IRET and context restored
945, 45, CPU execution
990, 1, check priority of interrupt
991, 1, check if masked
992, 5, switch to kernel mode and context saved
997, 1, find vector 18 in memory position 0x0024
998, 1, load address 0X054B into the PC
999, 151, END_IO
1150, 6, IRET and context restored

Performance Metrics:
Total Execution Time: 1156
Total Context Switches: 6
Total ISR Executions: 6
Time Spent on Vector Table Lookups: 6
Time Spent in Interrupt Handling: 635
Time Spent in CPU Operations: 295
Time Spent in I/O Operations: 118
Total Context Switch Time: 90
CPU Utilization: 25.52%
Average I/O Response Time: 0.00
Ratio of CPU to I/O Time: 2.50
System Throughput: 0.01 ISRs per time unit
min_context_time: 5
max_context_time: 10
0, 50, CPU execution
50, 2, switch to kernel mode and context saved
52, 1, find vector 7 in memory position 0x000e
53, 1, load address 0X0218 into the PC
54, 38, SYSCALL: run the ISR
92, 38, transfer data
130, 20, check for errors
150, 2, IRET and context restored
152, 30, CPU execution
182, 1, check priority of interrupt
183, 1, check if masked
184, 2, switch to kernel mode and context saved
186, 1, find vector 20 in memory position 0x0028
187, 1, load address 0X0531 into the PC
188, 144, END_IO
332, 2, IRET and context restored
334, 40, CPU execution
374, 1, switch to kernel mode and context saved
375, 1, find vector 12 in memory position 0x0018
376, 1, load address 0X064A into the PC
377, 46, SYSCALL: run the ISR
423, 46, transfer data
469, 25, check for errors
494, 2, IRET and context restored
496, 60, CPU execution
556, 1, check priority of interrupt
557, 1, check if masked
558, 2, switch to kernel mode and context saved
560, 1, find vector 22 in memory position 0x002C
561, 1, load address 0X0620 into the PC
562, 174, END_IO
736, 2, IRET and context restored
738, 70, CPU execution
808, 1, switch to kernel mode and context saved
809, 1, find vector 5 in memory position 0x000A
810, 1, load address 0X0642 into the PC
811, 42, SYSCALL: run the ISR
853, 42, transfer data
895, 23, check for errors
918, 2, IRET and context restored
920, 45, CPU execution
965, 1, check priority of interrupt
966, 1, check if masked
967, 1, switch to kernel mode and context saved
968, 1, find vector 18 in memory position 0x0024
969, 1, load address 0X054B into the PC
970, 155, END_IO
1125, 1, IRET and context restored

Performance Metrics:
Total Execution Time: 1126
Total Context Switches: 6
Total ISR Executions: 6
Time Spent on Vector Table Lookups: 6
Time Spent in Interrupt Handling: 667
Time Spent in CPU Operations: 295
Time Spent in I/O Operations: 126
Total Context Switch Time: 20
CPU Utilization: 26.20%
Average I/O Response Time: 0.00
Ratio of CPU to I/O Time: 2.34
System Throughput: 0.01 ISRs per time unit
min_context_time: 1
max_context_time: 3
CPU, 50
SYSCALL 7, 200
CPU, 30
END_IO 20, 150
CPU, 40
SYSCALL 12, 240
CPU, 60
END_IO 22, 180
CPU, 70
SYSCALL 5, 220
CPU, 45
END_IO 18, 1600X01E3
0X029C
0X0695
0X042B
0X0292
0X048B
0X0639
0X00BD
0X06EF
0X036C
0X07B0
0X01F8
0X03B9
0X06C7
0X0165
0X0584
0X02DF
0X05B3
0X060A
0X0765
0X07B7
0X0523
0X03B7
0X028C
0X05E8
0X05D3
#!/bin/bash

# Change to the Part2 directory
cd ./Assignment1/Part2

./interrupts "simulations/isr/trace_1.txt" "simulations/isr/vector_table.txt" "simulations/isr/output/execution_1.txt" 
./interrupts "simulations/isr/trace_2.txt" "simulations/isr/vector_table.txt" "simulations/isr/output/execution_2.txt" 
./interrupts "simulations/isr/trace_3.txt" "simulations/isr/vector_table.txt" "simulations/isr/output/execution_3.txt" 
./interrupts "simulations/isr/trace_4.txt" "simulations/isr/vector_table.txt" "simulations/isr/output/execution_4.txt" 
./interrupts "simulations/isr/trace_5.txt" "simulations/isr/vector_table.txt" "simulations/isr/output/execution_5.txt" 
CPU, 50
SYSCALL 7, 100
CPU, 30
END_IO 20, 150
CPU, 40
SYSCALL 12, 120
CPU, 60
END_IO 22, 180
CPU, 70CPU, 50
SYSCALL 7, 400
CPU, 30
END_IO 20, 150
CPU, 40
SYSCALL 12, 480
CPU, 60
END_IO 22, 180
CPU, 70
SYSCALL 5, 440
CPU, 45
END_IO 18, 160s0, 50, CPU execution
50, 1, switch to kernel mode and context saved
51, 1, find vector 7 in memory position 0x000e
52, 1, load address 0X00BD into the PC
53, 318, SYSCALL: run the ISR
371, 318, transfer data
689, 161, check for errors
850, 2, IRET and context restored
852, 30, CPU execution
882, 1, check priority of interrupt
883, 1, check if masked
884, 1, switch to kernel mode and context saved
885, 1, find vector 20 in memory position 0x0028
886, 1, load address 0X07B7 into the PC
887, 145, END_IO
1032, 3, IRET and context restored
1035, 40, CPU execution
1075, 3, switch to kernel mode and context saved
1078, 1, find vector 12 in memory position 0x0018
1079, 1, load address 0X03B9 into the PC
1080, 382, SYSCALL: run the ISR
1462, 382, transfer data
1844, 191, check for errors
2035, 1, IRET and context restored
2036, 60, CPU execution
2096, 1, check priority of interrupt
2097, 1, check if masked
2098, 2, switch to kernel mode and context saved
2100, 1, find vector 22 in memory position 0x002C
2101, 1, load address 0X03B7 into the PC
2102, 174, END_IO
2276, 1, IRET and context restored
2277, 70, CPU execution
2347, 3, switch to kernel mode and context saved
2350, 1, find vector 5 in memory position 0x000A
2351, 1, load address 0X048B into the PC
2352, 350, SYSCALL: run the ISR
2702, 350, transfer data
3052, 175, check for errors
3227, 1, IRET and context restored
3228, 45, CPU execution
3273, 1, check priority of interrupt
3274, 1, check if masked
3275, 2, switch to kernel mode and context saved
3277, 1, find vector 18 in memory position 0x0024
3278, 1, load address 0X060A into the PC
3279, 154, END_IO
3433, 1, IRET and context restored

Performance Metrics:
Total Execution Time: 3434
Total Context Switches: 6
Total ISR Executions: 6
Time Spent on Vector Table Lookups: 6
Time Spent in Interrupt Handling: 2050
Time Spent in CPU Operations: 295
Time Spent in I/O Operations: 1050
Total Context Switch Time: 21
Total Syscall Time: 2644
Total ISR Execution Time: 3100
CPU Utilization: 8.59%
Average I/O Response Time: 0.00
Ratio of CPU to I/O Time: 0.28
System Throughput: 0.00 ISRs per time unit
min_context_time: 1
max_context_time: 3
0, 50, CPU execution
50, 3, switch to kernel mode and context saved
53, 1, find vector 7 in memory position 0x000e
54, 1, load address 0X00BD into the PC
55, 158, SYSCALL: run the ISR
213, 158, transfer data
371, 79, check for errors
450, 1, IRET and context restored
451, 30, CPU execution
481, 1, check priority of interrupt
482, 1, check if masked
483, 1, switch to kernel mode and context saved
484, 1, find vector 20 in memory position 0x0028
485, 1, load address 0X07B7 into the PC
486, 145, END_IO
631, 2, IRET and context restored
633, 40, CPU execution
673, 2, switch to kernel mode and context saved
675, 1, find vector 12 in memory position 0x0018
676, 1, load address 0X03B9 into the PC
677, 190, SYSCALL: run the ISR
867, 190, transfer data
1057, 96, check for errors
1153, 2, IRET and context restored
1155, 60, CPU execution
1215, 1, check priority of interrupt
1216, 1, check if masked
1217, 1, switch to kernel mode and context saved
1218, 1, find vector 22 in memory position 0x002C
1219, 1, load address 0X03B7 into the PC
1220, 175, END_IO
1395, 1, IRET and context restored
1396, 70, CPU execution
1466, 1, switch to kernel mode and context saved
1467, 1, find vector 5 in memory position 0x000A
1468, 1, load address 0X048B into the PC
1469, 174, SYSCALL: run the ISR
1643, 174, transfer data
1817, 89, check for errors
1906, 2, IRET and context restored
1908, 45, CPU execution
1953, 1, check priority of interrupt
1954, 1, check if masked
1955, 2, switch to kernel mode and context saved
1957, 1, find vector 18 in memory position 0x0024
1958, 1, load address 0X060A into the PC
1959, 154, END_IO
2113, 2, IRET and context restored

Performance Metrics:
Total Execution Time: 2115
Total Context Switches: 6
Total ISR Executions: 6
Time Spent on Vector Table Lookups: 6
Time Spent in Interrupt Handling: 1260
Time Spent in CPU Operations: 295
Time Spent in I/O Operations: 522
Total Context Switch Time: 20
Total Syscall Time: 1325
Total ISR Execution Time: 1782
CPU Utilization: 13.95%
Average I/O Response Time: 0.00
Ratio of CPU to I/O Time: 0.57
System Throughput: 0.00 ISRs per time unit
min_context_time: 1
max_context_time: 3
0, 50, CPU execution
50, 3, switch to kernel mode and context saved
53, 1, find vector 7 in memory position 0x000e
54, 1, load address 0X00BD into the PC
55, 38, SYSCALL: run the ISR
93, 38, transfer data
131, 19, check for errors
150, 3, IRET and context restored
153, 30, CPU execution
183, 1, check priority of interrupt
184, 1, check if masked
185, 3, switch to kernel mode and context saved
188, 1, find vector 20 in memory position 0x0028
189, 1, load address 0X07B7 into the PC
190, 143, END_IO
333, 2, IRET and context restored
335, 40, CPU execution
375, 2, switch to kernel mode and context saved
377, 1, find vector 12 in memory position 0x0018
378, 1, load address 0X03B9 into the PC
379, 46, SYSCALL: run the ISR
425, 46, transfer data
471, 24, check for errors
495, 1, IRET and context restored
496, 60, CPU execution
556, 1, check priority of interrupt
557, 1, check if masked
558, 2, switch to kernel mode and context saved
560, 1, find vector 22 in memory position 0x002C
561, 1, load address 0X03B7 into the PC
562, 174, END_IO
736, 3, IRET and context restored
739, 70, CPU execution
809, 1, switch to kernel mode and context saved
810, 1, find vector 5 in memory position 0x000A
811, 1, load address 0X048B into the PC
812, 42, SYSCALL: run the ISR
854, 42, transfer data
896, 23, check for errors
919, 3, IRET and context restored
922, 45, CPU execution
967, 1, check priority of interrupt
968, 1, check if masked
969, 1, switch to kernel mode and context saved
970, 1, find vector 18 in memory position 0x0024
971, 1, load address 0X060A into the PC
972, 155, END_IO
1127, 3, IRET and context restored

Performance Metrics:
Total Execution Time: 1130
Total Context Switches: 6
Total ISR Executions: 6
Time Spent on Vector Table Lookups: 6
Time Spent in Interrupt Handling: 664
Time Spent in CPU Operations: 295
Time Spent in I/O Operations: 126
Total Context Switch Time: 27
Total Syscall Time: 337
Total ISR Execution Time: 790
CPU Utilization: 26.11%
Average I/O Response Time: 0.00
Ratio of CPU to I/O Time: 2.34
System Throughput: 0.01 ISRs per time unit
min_context_time: 1
max_context_time: 3
0, 50, CPU execution
50, 1, switch to kernel mode and context saved
51, 1, find vector 7 in memory position 0x000e
52, 1, load address 0X00BD into the PC
53, 78, SYSCALL: run the ISR
131, 78, transfer data
209, 41, check for errors
250, 1, IRET and context restored
251, 30, CPU execution
281, 1, check priority of interrupt
282, 1, check if masked
283, 3, switch to kernel mode and context saved
286, 1, find vector 20 in memory position 0x0028
287, 1, load address 0X07B7 into the PC
288, 143, END_IO
431, 3, IRET and context restored
434, 40, CPU execution
474, 2, switch to kernel mode and context saved
476, 1, find vector 12 in memory position 0x0018
477, 1, load address 0X03B9 into the PC
478, 94, SYSCALL: run the ISR
572, 94, transfer data
666, 48, check for errors
714, 1, IRET and context restored
715, 60, CPU execution
775, 1, check priority of interrupt
776, 1, check if masked
777, 3, switch to kernel mode and context saved
780, 1, find vector 22 in memory position 0x002C
781, 1, load address 0X03B7 into the PC
782, 173, END_IO
955, 3, IRET and context restored
958, 70, CPU execution
1028, 3, switch to kernel mode and context saved
1031, 1, find vector 5 in memory position 0x000A
1032, 1, load address 0X048B into the PC
1033, 86, SYSCALL: run the ISR
1119, 86, transfer data
1205, 43, check for errors
1248, 2, IRET and context restored
1250, 45, CPU execution
1295, 1, check priority of interrupt
1296, 1, check if masked
1297, 1, switch to kernel mode and context saved
1298, 1, find vector 18 in memory position 0x0024
1299, 1, load address 0X060A into the PC
1300, 155, END_IO
1455, 2, IRET and context restored

Performance Metrics:
Total Execution Time: 1457
Total Context Switches: 6
Total ISR Executions: 6
Time Spent on Vector Table Lookups: 6
Time Spent in Interrupt Handling: 861
Time Spent in CPU Operations: 295
Time Spent in I/O Operations: 258
Total Context Switch Time: 25
Total Syscall Time: 664
Total ISR Execution Time: 1119
CPU Utilization: 20.25%
Average I/O Response Time: 0.00
Ratio of CPU to I/O Time: 1.14
System Throughput: 0.00 ISRs per time unit
min_context_time: 1
max_context_time: 3
0, 50, CPU execution
50, 2, switch to kernel mode and context saved
52, 1, find vector 7 in memory position 0x000e
53, 1, load address 0X00BD into the PC
54, 38, SYSCALL: run the ISR
92, 38, transfer data
130, 20, check for errors
150, 2, IRET and context restored
152, 30, CPU execution
182, 1, check priority of interrupt
183, 1, check if masked
184, 1, switch to kernel mode and context saved
185, 1, find vector 20 in memory position 0x0028
186, 1, load address 0X07B7 into the PC
187, 145, END_IO
332, 3, IRET and context restored
335, 40, CPU execution
375, 3, switch to kernel mode and context saved
378, 1, find vector 12 in memory position 0x0018
379, 1, load address 0X03B9 into the PC
380, 46, SYSCALL: run the ISR
426, 46, transfer data
472, 23, check for errors
495, 3, IRET and context restored
498, 60, CPU execution
558, 1, check priority of interrupt
559, 1, check if masked
560, 1, switch to kernel mode and context saved
561, 1, find vector 22 in memory position 0x002C
562, 1, load address 0X03B7 into the PC
563, 175, END_IO
738, 1, IRET and context restored
739, 70, CPU execution

Performance Metrics:
Total Execution Time: 809
Total Context Switches: 4
Total ISR Executions: 4
Time Spent on Vector Table Lookups: 4
Time Spent in Interrupt Handling: 447
Time Spent in CPU Operations: 250
Time Spent in I/O Operations: 84
Total Context Switch Time: 16
Total Syscall Time: 225
Total ISR Execution Time: 531
CPU Utilization: 30.90%
Average I/O Response Time: 0.00
Ratio of CPU to I/O Time: 2.98
System Throughput: 0.00 ISRs per time unit
min_context_time: 1
max_context_time: 3
CPU, 50
SYSCALL 7, 800
CPU, 30
END_IO 20, 150
CPU, 40
SYSCALL 12, 960
CPU, 60
END_IO 22, 180
CPU, 70
SYSCALL 5, 880
CPU, 45
END_IO 18, 160CPU, 50
SYSCALL 7, 100
CPU, 30
END_IO 20, 150
CPU, 40
SYSCALL 12, 120
CPU, 60
END_IO 22, 180
CPU, 70
SYSCALL 5, 110
CPU, 45
END_IO 18, 1600X01E3
0X029C
0X0695
0X042B
0X0292
0X048B
0X0639
0X00BD
0X06EF
0X036C
0X07B0
0X01F8
0X03B9
0X06C7
0X0165
0X0584
0X02DF
0X05B3
0X060A
0X0765
0X07B7
0X0523
0X03B7
0X028C
0X05E8
0X05D3
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <sstream>
#include <random>
#include <chrono>
#include <iomanip>
#include <map>
struct Activity
{
    std::string type;
    int duration;
};

struct VectorTableEntry
{
    int syscall_number;
    int isr_address;
};

std::vector<VectorTableEntry> readVectorTable(const std::string &filename)
{
    std::vector<VectorTableEntry> vectorTable;
    std::ifstream file(filename);
    std::string line;
    int syscall_number = 0;

    if (!file.is_open())
    {
        throw std::runtime_error("Unable to open vector table file: " + filename);
    }

    while (std::getline(file, line))
    {
        int isr_address;
        std::istringstream iss(line);
        if (iss >> std::hex >> isr_address)
        {
            vectorTable.push_back({syscall_number, isr_address});
            syscall_number++;
        }
    }

    return vectorTable;
}

std::vector<Activity> readTrace(const std::string &filename)
{
    std::vector<Activity> trace;
    std::ifstream file(filename);
    std::string line;

    if (!file.is_open())
    {
        throw std::runtime_error("Unable to open trace file: " + filename);
    }

    while (std::getline(file, line))
    {
        std::istringstream iss(line);
        std::string type;
        int duration;

        if (std::getline(iss, type, ',') && iss >> duration)
        {
            trace.push_back({type, duration});
        }
    }

    return trace;
}

struct PerformanceMetrics
{
    int totalExecutionTime = 0;
    int totalContextSwitches = 0;
    int totalISRExecutions = 0;
    int timeSpentOnVectorTableLookups = 0;
    int timeSpentInInterruptHandling = 0;
    int timeSpentInCPUOperations = 0;
    int timeSpentInIOOperations = 0;
    int totalContextSwitchTime = 0;
    int totalSyscallTime = 0;
    int totalISRExecutionTime = 0;
    std::vector<int> ioResponseTimes;
    std::map<int, int> syscallStartTimes;
};
void simulateInterrupts(const std::vector<Activity> &trace, const std::vector<VectorTableEntry> &vectorTable, const std::string &outputFile, int min_context_time = 1, int max_context_time = 3)
{
    // Open output file
    std::ofstream execFile(outputFile);
    if (!execFile.is_open())
    {
        throw std::runtime_error("Unable to open output file: " + outputFile);
    }

    int currentTime = 0;
    // Initialize random number generator for context switch times
    std::mt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count());
    std::uniform_int_distribution<> contextDist(min_context_time, max_context_time);

    // Initialize performance metrics
    PerformanceMetrics metrics;

    // Iterate through each activity in the trace
    for (const auto &activity : trace)
    {
        if (activity.type == "CPU")
        {
            // Handle CPU operations
            execFile << currentTime << ", " << activity.duration << ", CPU execution\n";
            currentTime += activity.duration;
            metrics.totalExecutionTime += activity.duration;
            metrics.timeSpentInCPUOperations += activity.duration;
        }
        else if (activity.type.find("SYSCALL") != std::string::npos)
        {
            // Handle system calls
            int syscall_num = std::stoi(activity.type.substr(7));
            int syscallStartTime = currentTime;

            // Context switch to kernel mode
            int contextSwitchTime = contextDist(rng);
            execFile << currentTime << ", " << contextSwitchTime << ", switch to kernel mode and context saved\n";
            currentTime += contextSwitchTime;
            metrics.totalContextSwitches++;
            metrics.totalExecutionTime += contextSwitchTime;
            metrics.totalContextSwitchTime += contextSwitchTime;

            // Find vector in memory
            execFile << currentTime << ", 1, find vector " << syscall_num << " in memory position 0x"
                     << std::hex << std::setw(4) << std::setfill('0') << (syscall_num * 2) << std::dec << "\n";
            currentTime += 1;
            metrics.timeSpentOnVectorTableLookups += 1;
            metrics.totalExecutionTime += 1;

            // Load ISR address into PC
            execFile << currentTime << ", 1, load address 0X"
                     << std::hex << std::uppercase << std::setw(4) << std::setfill('0')
                     << vectorTable[syscall_num].isr_address << std::dec << " into the PC\n";
            currentTime += 1;
            metrics.totalISRExecutions++;
            metrics.totalExecutionTime += 1;

            // Calculate ISR execution times
            int totalIsrTime = activity.duration - 2 - contextSwitchTime;
            int runIsrTime = totalIsrTime * 2 / 5;
            int transferDataTime = totalIsrTime * 2 / 5;
            int checkErrorsTime = totalIsrTime - runIsrTime - transferDataTime;

            // Run ISR
            execFile << currentTime << ", " << runIsrTime << ", SYSCALL: run the ISR\n";
            currentTime += runIsrTime;
            metrics.timeSpentInInterruptHandling += runIsrTime;
            metrics.totalExecutionTime += runIsrTime;

            // Transfer data
            execFile << currentTime << ", " << transferDataTime << ", transfer data\n";
            currentTime += transferDataTime;
            metrics.timeSpentInIOOperations += transferDataTime;
            metrics.totalExecutionTime += transferDataTime;

            // Check for errors
            execFile << currentTime << ", " << checkErrorsTime << ", check for errors\n";
            currentTime += checkErrorsTime;
            metrics.timeSpentInInterruptHandling += checkErrorsTime;
            metrics.totalExecutionTime += checkErrorsTime;

            // Return from interrupt
            int iretTime = contextDist(rng);
            execFile << currentTime << ", " << iretTime << ", IRET and context restored\n";
            currentTime += iretTime;
            metrics.totalExecutionTime += iretTime;
            metrics.totalContextSwitchTime += iretTime;

            metrics.syscallStartTimes[syscall_num] = currentTime;
            metrics.totalSyscallTime += (currentTime - syscallStartTime);
            metrics.totalISRExecutionTime += totalIsrTime;
        }
        else if (activity.type.find("END_IO") != std::string::npos)
        {
            // Handle I/O completion
            int io_num = std::stoi(activity.type.substr(6));

            // Check interrupt priority and mask
            execFile << currentTime << ", 1, check priority of interrupt\n";
            currentTime += 1;
            execFile << currentTime << ", 1, check if masked\n";
            currentTime += 1;

            // Context switch to kernel mode
            int contextSwitchTime = contextDist(rng);
            execFile << currentTime << ", " << contextSwitchTime << ", switch to kernel mode and context saved\n";
            currentTime += contextSwitchTime;
            metrics.totalContextSwitches++;
            metrics.totalExecutionTime += contextSwitchTime + 2;
            metrics.totalContextSwitchTime += contextSwitchTime;

            // Find vector in memory
            execFile << currentTime << ", 1, find vector " << io_num << " in memory position 0x"
                     << std::hex << std::setw(4) << std::setfill('0') << (io_num * 2) << std::dec << "\n";
            currentTime += 1;
            metrics.timeSpentOnVectorTableLookups += 1;
            metrics.totalExecutionTime += 1;

            // Load ISR address into PC
            execFile << currentTime << ", 1, load address 0X"
                     << std::hex << std::uppercase << std::setw(4) << std::setfill('0')
                     << vectorTable[io_num].isr_address << std::dec << " into the PC\n";
            currentTime += 1;
            metrics.totalISRExecutions++;
            metrics.totalExecutionTime += 1;

            // Handle I/O completion
            int ioHandlingTime = activity.duration - 4 - contextSwitchTime;
            execFile << currentTime << ", " << ioHandlingTime << ", END_IO\n";
            currentTime += ioHandlingTime;
            metrics.timeSpentInInterruptHandling += ioHandlingTime;
            metrics.totalExecutionTime += ioHandlingTime;
            metrics.totalISRExecutionTime += ioHandlingTime;

            // Return from interrupt
            int iretTime = contextDist(rng);
            execFile << currentTime << ", " << iretTime << ", IRET and context restored\n";
            currentTime += iretTime;
            metrics.totalExecutionTime += iretTime;
            metrics.totalContextSwitchTime += iretTime;

            // Calculate I/O response time
            if (metrics.syscallStartTimes.find(io_num) != metrics.syscallStartTimes.end())
            {
                int responseTime = currentTime - metrics.syscallStartTimes[io_num];
                metrics.ioResponseTimes.push_back(responseTime);
                metrics.syscallStartTimes.erase(io_num);
            }
        }
    }

    // Calculate additional metrics
    int totalIOTime = metrics.timeSpentInIOOperations;
    int totalCPUTime = metrics.timeSpentInCPUOperations;
    double cpuUtilization = static_cast<double>(totalCPUTime) / metrics.totalExecutionTime * 100.0;
    double averageIOResponseTime = 0;
    if (!metrics.ioResponseTimes.empty())
    {
        averageIOResponseTime = static_cast<double>(std::accumulate(metrics.ioResponseTimes.begin(), metrics.ioResponseTimes.end(), 0)) / metrics.ioResponseTimes.size();
    }

    // Write all performance metrics to the output file
    execFile << "\nPerformance Metrics:\n";
    execFile << "Total Execution Time: " << metrics.totalExecutionTime << "\n";
    execFile << "Total Context Switches: " << metrics.totalContextSwitches << "\n";
    execFile << "Total ISR Executions: " << metrics.totalISRExecutions << "\n";
    execFile << "Time Spent on Vector Table Lookups: " << metrics.timeSpentOnVectorTableLookups << "\n";
    execFile << "Time Spent in Interrupt Handling: " << metrics.timeSpentInInterruptHandling << "\n";
    execFile << "Time Spent in CPU Operations: " << metrics.timeSpentInCPUOperations << "\n";
    execFile << "Time Spent in I/O Operations: " << metrics.timeSpentInIOOperations << "\n";
    execFile << "Total Context Switch Time: " << metrics.totalContextSwitchTime << "\n";
    execFile << "Total Syscall Time: " << metrics.totalSyscallTime << "\n";
    execFile << "Total ISR Execution Time: " << metrics.totalISRExecutionTime << "\n";
    execFile << "CPU Utilization: " << std::fixed << std::setprecision(2) << cpuUtilization << "%\n";
    execFile << "Average I/O Response Time: " << std::fixed << std::setprecision(2) << averageIOResponseTime << "\n";
    execFile << "Ratio of CPU to I/O Time: " << std::fixed << std::setprecision(2) << static_cast<double>(totalCPUTime) / totalIOTime << "\n";
    execFile << "System Throughput: " << std::fixed << std::setprecision(2) << static_cast<double>(metrics.totalISRExecutions) / metrics.totalExecutionTime << " ISRs per time unit\n";
    execFile << "Number of I/O Operations: " << metrics.ioResponseTimes.size() << "\n";
    execFile << "Average Syscall Time: " << std::fixed << std::setprecision(2) << static_cast<double>(metrics.totalSyscallTime) / metrics.totalISRExecutions << "\n";
    execFile << "Average ISR Execution Time: " << std::fixed << std::setprecision(2) << static_cast<double>(metrics.totalISRExecutionTime) / metrics.totalISRExecutions << "\n";
    execFile << "min_context_time: " << min_context_time << "\n";
    execFile << "max_context_time: " << max_context_time << "\n";

    execFile.close();
}
int main(int argc, char *argv[])
{
    if (argc < 4 || argc > 6)
    {
        std::cerr << "Usage: " << argv[0] << " <trace_file> <vector_table_file> <output_file> [min_context_time] [max_context_time]\n";
        return 1;
    }

    try
    {
        std::vector<Activity> trace = readTrace(argv[1]);
        std::vector<VectorTableEntry> vectorTable = readVectorTable(argv[2]);

        if (argc == 4)
        {
            simulateInterrupts(trace, vectorTable, argv[3]);
        }
        else if (argc == 6)
        {
            int min_context_time = std::stoi(argv[4]);
            int max_context_time = std::stoi(argv[5]);
            simulateInterrupts(trace, vectorTable, argv[3], min_context_time, max_context_time);
        }
        else
        {
            std::cerr << "Invalid number of arguments\n";
            return 1;
        }
    }
    catch (const std::exception &e)
    {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }

    return 0;
}
#!/bin/bash

# Change to the Part2 directory
cd ./Assignment1/Part2 || exit 1

# Compile the C++ program
g++ -std=c++11 interrupts.cpp -o interrupts

# Check if compilation was successful
if [ $? -ne 0 ]; then
    echo "Compilation failed. Exiting."
    exit 1
fi

# Loop through each numbered subfolder in the simulations directory
for sim_num in 1 2 3 4 5; do
    echo "Running simulation $sim_num"
    
    # Check if trace file exists
    if [ ! -f "simulations/$sim_num/trace.txt" ]; then
        echo "Trace file not found for simulation $sim_num. Skipping."
        continue
    fi
    
    # Run the interrupt simulator
    ./interrupts "simulations/$sim_num/trace.txt" "simulations/$sim_num/vector_table.txt" "simulations/$sim_num/execution.txt"
    
    # Check if the simulation was successful
    if [ $? -eq 0 ]; then
        echo "Simulation $sim_num completed successfully"
    else
        echo "Simulation $sim_num failed"
    fi
    
    echo "------------------------"
done

echo "All simulations completed"